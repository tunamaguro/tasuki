//! Code generated by sqlc-gen-rust. SHOULD NOT EDIT.
//! sqlc version: v1.29.0
//! sqlc-gen-rust version: v0.1.9

pub struct CopyDataSink<C: std::ops::DerefMut<Target = sqlx::PgConnection>> {
    encode_buf: sqlx::postgres::PgArgumentBuffer,
    data_buf: Vec<u8>,
    copy_in: sqlx::postgres::PgCopyIn<C>,
}
impl<C: std::ops::DerefMut<Target = sqlx::PgConnection>> CopyDataSink<C> {
    const BUFFER_SIZE: usize = 4096;
    fn new(copy_in: sqlx::postgres::PgCopyIn<C>) -> Self {
        let mut data_buf = Vec::with_capacity(Self::BUFFER_SIZE);
        const COPY_SIGNATURE: &[u8] = &[
            b'P', b'G', b'C', b'O', b'P', b'Y', b'\n', 0xFF, b'\r', b'\n', 0x00,
        ];
        assert_eq!(COPY_SIGNATURE.len(), 11);
        data_buf.extend_from_slice(COPY_SIGNATURE);
        data_buf.extend(0_i32.to_be_bytes());
        data_buf.extend(0_i32.to_be_bytes());
        CopyDataSink {
            encode_buf: Default::default(),
            data_buf,
            copy_in,
        }
    }
    async fn send(&mut self) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        let _copy_in = self.copy_in.send(self.data_buf.as_slice()).await?;
        self.data_buf.clear();
        Ok(())
    }
    /// Complete copy process and return number of rows affected.
    pub async fn finish(mut self) -> Result<u64, Box<dyn std::error::Error + Send + Sync>> {
        const COPY_TRAILER: &[u8] = &(-1_i16).to_be_bytes();
        self.data_buf.extend(COPY_TRAILER);
        self.send().await?;
        self.copy_in.finish().await.map_err(|e| e.into())
    }
    fn insert_row(&mut self) {
        let num_col = self.copy_in.num_columns() as i16;
        self.data_buf.extend(num_col.to_be_bytes());
    }
    async fn add<'q, T>(
        &mut self,
        value: &T,
    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>>
    where
        T: sqlx::Encode<'q, sqlx::Postgres> + sqlx::Type<sqlx::Postgres>,
    {
        let is_null = value.encode_by_ref(&mut self.encode_buf)?;
        match is_null {
            sqlx::encode::IsNull::Yes => {
                self.data_buf.extend((-1_i32).to_be_bytes());
            }
            sqlx::encode::IsNull::No => {
                self.data_buf
                    .extend((self.encode_buf.len() as i32).to_be_bytes());
                self.data_buf.extend_from_slice(self.encode_buf.as_slice());
            }
        }
        self.encode_buf.clear();
        if self.data_buf.len() > Self::BUFFER_SIZE {
            self.send().await?;
        }
        Ok(())
    }
}
#[derive(Debug, Clone, Copy, sqlx::Type)]
#[sqlx(type_name = "tasuki_job_status")]
pub enum TasukiJobStatus {
    #[sqlx(rename = "pending")]
    Pending,
    #[sqlx(rename = "running")]
    Running,
    #[sqlx(rename = "completed")]
    Completed,
    #[sqlx(rename = "failed")]
    Failed,
    #[sqlx(rename = "canceled")]
    Canceled,
}
#[derive(sqlx::FromRow)]
pub struct GetAvailableJobsRow {
    #[sqlx(rename = "id")]
    pub id: sqlx::types::Uuid,
    #[sqlx(rename = "job_data")]
    pub job_data: serde_json::Value,
    #[sqlx(rename = "lease_token")]
    pub lease_token: sqlx::types::Uuid,
}
pub struct GetAvailableJobs<'a> {
    lease_interval: &'a sqlx::postgres::types::PgInterval,
    queue_name: &'a str,
    batch_size: i32,
}
impl<'a> GetAvailableJobs<'a> {
    pub const QUERY: &'static str = r"UPDATE 
  tasuki_job j
SET
  status = 'running'::tasuki_job_status,
  attempts = j.attempts + 1,
  lease_expires_at = clock_timestamp() + $1::INTERVAL,
  lease_token = gen_random_uuid()
WHERE 
  id in (
    SELECT 
      id 
    FROM
      tasuki_job
    WHERE 
      (
        (status = 'pending')
        OR
        (status = 'running' AND lease_expires_at IS NOT NULL AND lease_expires_at <= NOW())
      )
      AND 
      (scheduled_at <= NOW() AND attempts < max_attempts AND queue_name = $2::TEXT)
    ORDER BY scheduled_at ASC
    FOR UPDATE SKIP LOCKED
    LIMIT $3
  )
RETURNING j.id, j.job_data, j.lease_token::UUID AS lease_token";
    pub fn query_as(
        &'a self,
    ) -> sqlx::query::QueryAs<
        'a,
        sqlx::Postgres,
        GetAvailableJobsRow,
        <sqlx::Postgres as sqlx::Database>::Arguments<'a>,
    > {
        sqlx::query_as::<_, GetAvailableJobsRow>(Self::QUERY)
            .bind(self.lease_interval)
            .bind(self.queue_name)
            .bind(self.batch_size)
    }
    pub fn query_many<'b, A>(
        &'a self,
        conn: A,
    ) -> impl Future<Output = Result<Vec<GetAvailableJobsRow>, sqlx::Error>> + Send + 'a
    where
        A: sqlx::Acquire<'b, Database = sqlx::Postgres> + Send + 'a,
    {
        async move {
            let mut conn = conn.acquire().await?;
            let vals = self.query_as().fetch_all(&mut *conn).await?;
            Ok(vals)
        }
    }
}
impl<'a> GetAvailableJobs<'a> {
    pub const fn builder() -> GetAvailableJobsBuilder<'a, ((), (), ())> {
        GetAvailableJobsBuilder {
            fields: ((), (), ()),
            _phantom: std::marker::PhantomData,
        }
    }
}
pub struct GetAvailableJobsBuilder<'a, Fields = ((), (), ())> {
    fields: Fields,
    _phantom: std::marker::PhantomData<&'a ()>,
}
impl<'a, QueueName, BatchSize> GetAvailableJobsBuilder<'a, ((), QueueName, BatchSize)> {
    pub fn lease_interval(
        self,
        lease_interval: &'a sqlx::postgres::types::PgInterval,
    ) -> GetAvailableJobsBuilder<'a, (&'a sqlx::postgres::types::PgInterval, QueueName, BatchSize)>
    {
        let ((), queue_name, batch_size) = self.fields;
        let _phantom = self._phantom;
        GetAvailableJobsBuilder {
            fields: (lease_interval, queue_name, batch_size),
            _phantom,
        }
    }
}
impl<'a, LeaseInterval, BatchSize> GetAvailableJobsBuilder<'a, (LeaseInterval, (), BatchSize)> {
    pub fn queue_name(
        self,
        queue_name: &'a str,
    ) -> GetAvailableJobsBuilder<'a, (LeaseInterval, &'a str, BatchSize)> {
        let (lease_interval, (), batch_size) = self.fields;
        let _phantom = self._phantom;
        GetAvailableJobsBuilder {
            fields: (lease_interval, queue_name, batch_size),
            _phantom,
        }
    }
}
impl<'a, LeaseInterval, QueueName> GetAvailableJobsBuilder<'a, (LeaseInterval, QueueName, ())> {
    pub fn batch_size(
        self,
        batch_size: i32,
    ) -> GetAvailableJobsBuilder<'a, (LeaseInterval, QueueName, i32)> {
        let (lease_interval, queue_name, ()) = self.fields;
        let _phantom = self._phantom;
        GetAvailableJobsBuilder {
            fields: (lease_interval, queue_name, batch_size),
            _phantom,
        }
    }
}
impl<'a> GetAvailableJobsBuilder<'a, (&'a sqlx::postgres::types::PgInterval, &'a str, i32)> {
    pub const fn build(self) -> GetAvailableJobs<'a> {
        let (lease_interval, queue_name, batch_size) = self.fields;
        GetAvailableJobs {
            lease_interval,
            queue_name,
            batch_size,
        }
    }
}
#[derive(sqlx::FromRow)]
pub struct HeartBeatJobRow {
    #[sqlx(rename = "status")]
    pub status: TasukiJobStatus,
}
pub struct HeartBeatJob<'a> {
    lease_interval: &'a sqlx::postgres::types::PgInterval,
    id: sqlx::types::Uuid,
    lease_token: Option<sqlx::types::Uuid>,
}
impl<'a> HeartBeatJob<'a> {
    pub const QUERY: &'static str = r"UPDATE 
  tasuki_job j
SET
  lease_expires_at = CASE
    WHEN j.status = 'running'::tasuki_job_status
      THEN clock_timestamp() + $1::INTERVAL
    ELSE j.lease_expires_at
  END
WHERE
  id = $2
  AND lease_token = $3
RETURNING j.status";
    pub fn query_as(
        &'a self,
    ) -> sqlx::query::QueryAs<
        'a,
        sqlx::Postgres,
        HeartBeatJobRow,
        <sqlx::Postgres as sqlx::Database>::Arguments<'a>,
    > {
        sqlx::query_as::<_, HeartBeatJobRow>(Self::QUERY)
            .bind(self.lease_interval)
            .bind(self.id)
            .bind(self.lease_token)
    }
    pub fn query_one<'b, A>(
        &'a self,
        conn: A,
    ) -> impl Future<Output = Result<HeartBeatJobRow, sqlx::Error>> + Send + 'a
    where
        A: sqlx::Acquire<'b, Database = sqlx::Postgres> + Send + 'a,
    {
        async move {
            let mut conn = conn.acquire().await?;
            let val = self.query_as().fetch_one(&mut *conn).await?;
            Ok(val)
        }
    }
    pub fn query_opt<'b, A>(
        &'a self,
        conn: A,
    ) -> impl Future<Output = Result<Option<HeartBeatJobRow>, sqlx::Error>> + Send + 'a
    where
        A: sqlx::Acquire<'b, Database = sqlx::Postgres> + Send + 'a,
    {
        async move {
            let mut conn = conn.acquire().await?;
            let val = self.query_as().fetch_optional(&mut *conn).await?;
            Ok(val)
        }
    }
}
impl<'a> HeartBeatJob<'a> {
    pub const fn builder() -> HeartBeatJobBuilder<'a, ((), (), ())> {
        HeartBeatJobBuilder {
            fields: ((), (), ()),
            _phantom: std::marker::PhantomData,
        }
    }
}
pub struct HeartBeatJobBuilder<'a, Fields = ((), (), ())> {
    fields: Fields,
    _phantom: std::marker::PhantomData<&'a ()>,
}
impl<'a, Id, LeaseToken> HeartBeatJobBuilder<'a, ((), Id, LeaseToken)> {
    pub fn lease_interval(
        self,
        lease_interval: &'a sqlx::postgres::types::PgInterval,
    ) -> HeartBeatJobBuilder<'a, (&'a sqlx::postgres::types::PgInterval, Id, LeaseToken)> {
        let ((), id, lease_token) = self.fields;
        let _phantom = self._phantom;
        HeartBeatJobBuilder {
            fields: (lease_interval, id, lease_token),
            _phantom,
        }
    }
}
impl<'a, LeaseInterval, LeaseToken> HeartBeatJobBuilder<'a, (LeaseInterval, (), LeaseToken)> {
    pub fn id(
        self,
        id: sqlx::types::Uuid,
    ) -> HeartBeatJobBuilder<'a, (LeaseInterval, sqlx::types::Uuid, LeaseToken)> {
        let (lease_interval, (), lease_token) = self.fields;
        let _phantom = self._phantom;
        HeartBeatJobBuilder {
            fields: (lease_interval, id, lease_token),
            _phantom,
        }
    }
}
impl<'a, LeaseInterval, Id> HeartBeatJobBuilder<'a, (LeaseInterval, Id, ())> {
    pub fn lease_token(
        self,
        lease_token: Option<sqlx::types::Uuid>,
    ) -> HeartBeatJobBuilder<'a, (LeaseInterval, Id, Option<sqlx::types::Uuid>)> {
        let (lease_interval, id, ()) = self.fields;
        let _phantom = self._phantom;
        HeartBeatJobBuilder {
            fields: (lease_interval, id, lease_token),
            _phantom,
        }
    }
}
impl<'a>
    HeartBeatJobBuilder<
        'a,
        (
            &'a sqlx::postgres::types::PgInterval,
            sqlx::types::Uuid,
            Option<sqlx::types::Uuid>,
        ),
    >
{
    pub const fn build(self) -> HeartBeatJob<'a> {
        let (lease_interval, id, lease_token) = self.fields;
        HeartBeatJob {
            lease_interval,
            id,
            lease_token,
        }
    }
}
#[derive(sqlx::FromRow)]
pub struct CompleteJobRow {}
pub struct CompleteJob {
    id: sqlx::types::Uuid,
    lease_token: Option<sqlx::types::Uuid>,
}
impl CompleteJob {
    pub const QUERY: &'static str = r"UPDATE 
  tasuki_job j
SET 
  status = 'completed'::tasuki_job_status
WHERE
  id = $1
  AND lease_token = $2";
    pub fn query_as<'a>(
        &'a self,
    ) -> sqlx::query::QueryAs<
        'a,
        sqlx::Postgres,
        CompleteJobRow,
        <sqlx::Postgres as sqlx::Database>::Arguments<'a>,
    > {
        sqlx::query_as::<_, CompleteJobRow>(Self::QUERY)
            .bind(self.id)
            .bind(self.lease_token)
    }
    pub fn execute<'a, 'b, A>(
        &'a self,
        conn: A,
    ) -> impl Future<Output = Result<<sqlx::Postgres as sqlx::Database>::QueryResult, sqlx::Error>>
    + Send
    + 'a
    where
        A: sqlx::Acquire<'b, Database = sqlx::Postgres> + Send + 'a,
    {
        async move {
            let mut conn = conn.acquire().await?;
            sqlx::query(Self::QUERY)
                .bind(self.id)
                .bind(self.lease_token)
                .execute(&mut *conn)
                .await
        }
    }
}
impl CompleteJob {
    pub const fn builder() -> CompleteJobBuilder<'static, ((), ())> {
        CompleteJobBuilder {
            fields: ((), ()),
            _phantom: std::marker::PhantomData,
        }
    }
}
pub struct CompleteJobBuilder<'a, Fields = ((), ())> {
    fields: Fields,
    _phantom: std::marker::PhantomData<&'a ()>,
}
impl<'a, LeaseToken> CompleteJobBuilder<'a, ((), LeaseToken)> {
    pub fn id(
        self,
        id: sqlx::types::Uuid,
    ) -> CompleteJobBuilder<'a, (sqlx::types::Uuid, LeaseToken)> {
        let ((), lease_token) = self.fields;
        let _phantom = self._phantom;
        CompleteJobBuilder {
            fields: (id, lease_token),
            _phantom,
        }
    }
}
impl<'a, Id> CompleteJobBuilder<'a, (Id, ())> {
    pub fn lease_token(
        self,
        lease_token: Option<sqlx::types::Uuid>,
    ) -> CompleteJobBuilder<'a, (Id, Option<sqlx::types::Uuid>)> {
        let (id, ()) = self.fields;
        let _phantom = self._phantom;
        CompleteJobBuilder {
            fields: (id, lease_token),
            _phantom,
        }
    }
}
impl<'a> CompleteJobBuilder<'a, (sqlx::types::Uuid, Option<sqlx::types::Uuid>)> {
    pub const fn build(self) -> CompleteJob {
        let (id, lease_token) = self.fields;
        CompleteJob { id, lease_token }
    }
}
#[derive(sqlx::FromRow)]
pub struct CancelJobRow {}
pub struct CancelJob {
    id: sqlx::types::Uuid,
    lease_token: Option<sqlx::types::Uuid>,
}
impl CancelJob {
    pub const QUERY: &'static str = r"UPDATE
  tasuki_job j
SET
  status = 'canceled'::tasuki_job_status
WHERE
  id = $1
  AND lease_token = $2";
    pub fn query_as<'a>(
        &'a self,
    ) -> sqlx::query::QueryAs<
        'a,
        sqlx::Postgres,
        CancelJobRow,
        <sqlx::Postgres as sqlx::Database>::Arguments<'a>,
    > {
        sqlx::query_as::<_, CancelJobRow>(Self::QUERY)
            .bind(self.id)
            .bind(self.lease_token)
    }
    pub fn execute<'a, 'b, A>(
        &'a self,
        conn: A,
    ) -> impl Future<Output = Result<<sqlx::Postgres as sqlx::Database>::QueryResult, sqlx::Error>>
    + Send
    + 'a
    where
        A: sqlx::Acquire<'b, Database = sqlx::Postgres> + Send + 'a,
    {
        async move {
            let mut conn = conn.acquire().await?;
            sqlx::query(Self::QUERY)
                .bind(self.id)
                .bind(self.lease_token)
                .execute(&mut *conn)
                .await
        }
    }
}
impl CancelJob {
    pub const fn builder() -> CancelJobBuilder<'static, ((), ())> {
        CancelJobBuilder {
            fields: ((), ()),
            _phantom: std::marker::PhantomData,
        }
    }
}
pub struct CancelJobBuilder<'a, Fields = ((), ())> {
    fields: Fields,
    _phantom: std::marker::PhantomData<&'a ()>,
}
impl<'a, LeaseToken> CancelJobBuilder<'a, ((), LeaseToken)> {
    pub fn id(
        self,
        id: sqlx::types::Uuid,
    ) -> CancelJobBuilder<'a, (sqlx::types::Uuid, LeaseToken)> {
        let ((), lease_token) = self.fields;
        let _phantom = self._phantom;
        CancelJobBuilder {
            fields: (id, lease_token),
            _phantom,
        }
    }
}
impl<'a, Id> CancelJobBuilder<'a, (Id, ())> {
    pub fn lease_token(
        self,
        lease_token: Option<sqlx::types::Uuid>,
    ) -> CancelJobBuilder<'a, (Id, Option<sqlx::types::Uuid>)> {
        let (id, ()) = self.fields;
        let _phantom = self._phantom;
        CancelJobBuilder {
            fields: (id, lease_token),
            _phantom,
        }
    }
}
impl<'a> CancelJobBuilder<'a, (sqlx::types::Uuid, Option<sqlx::types::Uuid>)> {
    pub const fn build(self) -> CancelJob {
        let (id, lease_token) = self.fields;
        CancelJob { id, lease_token }
    }
}
#[derive(sqlx::FromRow)]
pub struct RetryJobRow {}
pub struct RetryJob<'a> {
    interval: Option<&'a sqlx::postgres::types::PgInterval>,
    id: sqlx::types::Uuid,
    lease_token: Option<sqlx::types::Uuid>,
}
impl<'a> RetryJob<'a> {
    pub const QUERY: &'static str = r"UPDATE tasuki_job j
SET 
  status = CASE 
            WHEN j.attempts < j.max_attempts THEN 'pending'::tasuki_job_status
            ELSE 'failed'::tasuki_job_status
           END,
  scheduled_at = CASE
                  WHEN j.attempts < j.max_attempts 
                    THEN clock_timestamp() + coalesce(
                      $1,
                      make_interval(secs := power(j.attempts, 4.0) * (0.9 + random() * 0.2))
                      )::INTERVAL
                  ELSE scheduled_at
                 END,
  lease_expires_at = NULL
WHERE 
  id = $2
  AND lease_token = $3";
    pub fn query_as(
        &'a self,
    ) -> sqlx::query::QueryAs<
        'a,
        sqlx::Postgres,
        RetryJobRow,
        <sqlx::Postgres as sqlx::Database>::Arguments<'a>,
    > {
        sqlx::query_as::<_, RetryJobRow>(Self::QUERY)
            .bind(self.interval)
            .bind(self.id)
            .bind(self.lease_token)
    }
    pub fn execute<'b, A>(
        &'a self,
        conn: A,
    ) -> impl Future<Output = Result<<sqlx::Postgres as sqlx::Database>::QueryResult, sqlx::Error>>
    + Send
    + 'a
    where
        A: sqlx::Acquire<'b, Database = sqlx::Postgres> + Send + 'a,
    {
        async move {
            let mut conn = conn.acquire().await?;
            sqlx::query(Self::QUERY)
                .bind(self.interval)
                .bind(self.id)
                .bind(self.lease_token)
                .execute(&mut *conn)
                .await
        }
    }
}
impl<'a> RetryJob<'a> {
    pub const fn builder() -> RetryJobBuilder<'a, ((), (), ())> {
        RetryJobBuilder {
            fields: ((), (), ()),
            _phantom: std::marker::PhantomData,
        }
    }
}
pub struct RetryJobBuilder<'a, Fields = ((), (), ())> {
    fields: Fields,
    _phantom: std::marker::PhantomData<&'a ()>,
}
impl<'a, Id, LeaseToken> RetryJobBuilder<'a, ((), Id, LeaseToken)> {
    pub fn interval(
        self,
        interval: Option<&'a sqlx::postgres::types::PgInterval>,
    ) -> RetryJobBuilder<
        'a,
        (
            Option<&'a sqlx::postgres::types::PgInterval>,
            Id,
            LeaseToken,
        ),
    > {
        let ((), id, lease_token) = self.fields;
        let _phantom = self._phantom;
        RetryJobBuilder {
            fields: (interval, id, lease_token),
            _phantom,
        }
    }
}
impl<'a, Interval, LeaseToken> RetryJobBuilder<'a, (Interval, (), LeaseToken)> {
    pub fn id(
        self,
        id: sqlx::types::Uuid,
    ) -> RetryJobBuilder<'a, (Interval, sqlx::types::Uuid, LeaseToken)> {
        let (interval, (), lease_token) = self.fields;
        let _phantom = self._phantom;
        RetryJobBuilder {
            fields: (interval, id, lease_token),
            _phantom,
        }
    }
}
impl<'a, Interval, Id> RetryJobBuilder<'a, (Interval, Id, ())> {
    pub fn lease_token(
        self,
        lease_token: Option<sqlx::types::Uuid>,
    ) -> RetryJobBuilder<'a, (Interval, Id, Option<sqlx::types::Uuid>)> {
        let (interval, id, ()) = self.fields;
        let _phantom = self._phantom;
        RetryJobBuilder {
            fields: (interval, id, lease_token),
            _phantom,
        }
    }
}
impl<'a>
    RetryJobBuilder<
        'a,
        (
            Option<&'a sqlx::postgres::types::PgInterval>,
            sqlx::types::Uuid,
            Option<sqlx::types::Uuid>,
        ),
    >
{
    pub const fn build(self) -> RetryJob<'a> {
        let (interval, id, lease_token) = self.fields;
        RetryJob {
            interval,
            id,
            lease_token,
        }
    }
}
#[derive(sqlx::FromRow)]
pub struct InsertJobOneRow {}
pub struct InsertJobOne<'a> {
    max_attempts: i32,
    job_data: &'a serde_json::Value,
    queue_name: &'a str,
    interval: &'a sqlx::postgres::types::PgInterval,
}
impl<'a> InsertJobOne<'a> {
    pub const QUERY: &'static str = r"INSERT INTO
  tasuki_job
  (max_attempts, job_data, queue_name, scheduled_at)
VALUES
  ($1, $2, $3, clock_timestamp() + $4::INTERVAL)";
    pub fn query_as(
        &'a self,
    ) -> sqlx::query::QueryAs<
        'a,
        sqlx::Postgres,
        InsertJobOneRow,
        <sqlx::Postgres as sqlx::Database>::Arguments<'a>,
    > {
        sqlx::query_as::<_, InsertJobOneRow>(Self::QUERY)
            .bind(self.max_attempts)
            .bind(self.job_data)
            .bind(self.queue_name)
            .bind(self.interval)
    }
    pub fn execute<'b, A>(
        &'a self,
        conn: A,
    ) -> impl Future<Output = Result<<sqlx::Postgres as sqlx::Database>::QueryResult, sqlx::Error>>
    + Send
    + 'a
    where
        A: sqlx::Acquire<'b, Database = sqlx::Postgres> + Send + 'a,
    {
        async move {
            let mut conn = conn.acquire().await?;
            sqlx::query(Self::QUERY)
                .bind(self.max_attempts)
                .bind(self.job_data)
                .bind(self.queue_name)
                .bind(self.interval)
                .execute(&mut *conn)
                .await
        }
    }
}
impl<'a> InsertJobOne<'a> {
    pub const fn builder() -> InsertJobOneBuilder<'a, ((), (), (), ())> {
        InsertJobOneBuilder {
            fields: ((), (), (), ()),
            _phantom: std::marker::PhantomData,
        }
    }
}
pub struct InsertJobOneBuilder<'a, Fields = ((), (), (), ())> {
    fields: Fields,
    _phantom: std::marker::PhantomData<&'a ()>,
}
impl<'a, JobData, QueueName, Interval> InsertJobOneBuilder<'a, ((), JobData, QueueName, Interval)> {
    pub fn max_attempts(
        self,
        max_attempts: i32,
    ) -> InsertJobOneBuilder<'a, (i32, JobData, QueueName, Interval)> {
        let ((), job_data, queue_name, interval) = self.fields;
        let _phantom = self._phantom;
        InsertJobOneBuilder {
            fields: (max_attempts, job_data, queue_name, interval),
            _phantom,
        }
    }
}
impl<'a, MaxAttempts, QueueName, Interval>
    InsertJobOneBuilder<'a, (MaxAttempts, (), QueueName, Interval)>
{
    pub fn job_data(
        self,
        job_data: &'a serde_json::Value,
    ) -> InsertJobOneBuilder<'a, (MaxAttempts, &'a serde_json::Value, QueueName, Interval)> {
        let (max_attempts, (), queue_name, interval) = self.fields;
        let _phantom = self._phantom;
        InsertJobOneBuilder {
            fields: (max_attempts, job_data, queue_name, interval),
            _phantom,
        }
    }
}
impl<'a, MaxAttempts, JobData, Interval>
    InsertJobOneBuilder<'a, (MaxAttempts, JobData, (), Interval)>
{
    pub fn queue_name(
        self,
        queue_name: &'a str,
    ) -> InsertJobOneBuilder<'a, (MaxAttempts, JobData, &'a str, Interval)> {
        let (max_attempts, job_data, (), interval) = self.fields;
        let _phantom = self._phantom;
        InsertJobOneBuilder {
            fields: (max_attempts, job_data, queue_name, interval),
            _phantom,
        }
    }
}
impl<'a, MaxAttempts, JobData, QueueName>
    InsertJobOneBuilder<'a, (MaxAttempts, JobData, QueueName, ())>
{
    pub fn interval(
        self,
        interval: &'a sqlx::postgres::types::PgInterval,
    ) -> InsertJobOneBuilder<
        'a,
        (
            MaxAttempts,
            JobData,
            QueueName,
            &'a sqlx::postgres::types::PgInterval,
        ),
    > {
        let (max_attempts, job_data, queue_name, ()) = self.fields;
        let _phantom = self._phantom;
        InsertJobOneBuilder {
            fields: (max_attempts, job_data, queue_name, interval),
            _phantom,
        }
    }
}
impl<'a>
    InsertJobOneBuilder<
        'a,
        (
            i32,
            &'a serde_json::Value,
            &'a str,
            &'a sqlx::postgres::types::PgInterval,
        ),
    >
{
    pub const fn build(self) -> InsertJobOne<'a> {
        let (max_attempts, job_data, queue_name, interval) = self.fields;
        InsertJobOne {
            max_attempts,
            job_data,
            queue_name,
            interval,
        }
    }
}
#[derive(sqlx::FromRow)]
pub struct InsertJobManyRow {}
pub struct InsertJobMany<'a> {
    max_attempts: i32,
    job_data: &'a serde_json::Value,
    queue_name: &'a str,
    scheduled_at: crate::PgDateTime,
}
impl<'a> InsertJobMany<'a> {
    pub const QUERY: &'static str = r"COPY tasuki_job (max_attempts,job_data,queue_name,scheduled_at) FROM STDIN (FORMAT BINARY)";
    pub fn query_as(
        &'a self,
    ) -> sqlx::query::QueryAs<
        'a,
        sqlx::Postgres,
        InsertJobManyRow,
        <sqlx::Postgres as sqlx::Database>::Arguments<'a>,
    > {
        sqlx::query_as::<_, InsertJobManyRow>(Self::QUERY)
            .bind(self.max_attempts)
            .bind(self.job_data)
            .bind(self.queue_name)
            .bind(self.scheduled_at)
    }
    pub async fn copy_in<PgCopy>(
        conn: &PgCopy,
    ) -> Result<CopyDataSink<sqlx::pool::PoolConnection<sqlx::Postgres>>, sqlx::Error>
    where
        PgCopy: sqlx::postgres::PgPoolCopyExt,
    {
        let copy_in = conn.copy_in_raw(Self::QUERY).await?;
        Ok(CopyDataSink::new(copy_in))
    }
    pub async fn copy_in_tx(
        conn: &mut sqlx::postgres::PgConnection,
    ) -> Result<CopyDataSink<&mut sqlx::postgres::PgConnection>, sqlx::Error> {
        let copy_in = conn.copy_in_raw(Self::QUERY).await?;
        Ok(CopyDataSink::new(copy_in))
    }
    pub async fn write<C: std::ops::DerefMut<Target = sqlx::PgConnection>>(
        &self,
        sink: &mut CopyDataSink<C>,
    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        sink.insert_row();
        sink.add(&self.max_attempts).await?;
        sink.add(&self.job_data).await?;
        sink.add(&self.queue_name).await?;
        sink.add(&self.scheduled_at).await?;
        Ok(())
    }
}
impl<'a> InsertJobMany<'a> {
    pub const fn builder() -> InsertJobManyBuilder<'a, ((), (), (), ())> {
        InsertJobManyBuilder {
            fields: ((), (), (), ()),
            _phantom: std::marker::PhantomData,
        }
    }
}
pub struct InsertJobManyBuilder<'a, Fields = ((), (), (), ())> {
    fields: Fields,
    _phantom: std::marker::PhantomData<&'a ()>,
}
impl<'a, JobData, QueueName, ScheduledAt>
    InsertJobManyBuilder<'a, ((), JobData, QueueName, ScheduledAt)>
{
    pub fn max_attempts(
        self,
        max_attempts: i32,
    ) -> InsertJobManyBuilder<'a, (i32, JobData, QueueName, ScheduledAt)> {
        let ((), job_data, queue_name, scheduled_at) = self.fields;
        let _phantom = self._phantom;
        InsertJobManyBuilder {
            fields: (max_attempts, job_data, queue_name, scheduled_at),
            _phantom,
        }
    }
}
impl<'a, MaxAttempts, QueueName, ScheduledAt>
    InsertJobManyBuilder<'a, (MaxAttempts, (), QueueName, ScheduledAt)>
{
    pub fn job_data(
        self,
        job_data: &'a serde_json::Value,
    ) -> InsertJobManyBuilder<'a, (MaxAttempts, &'a serde_json::Value, QueueName, ScheduledAt)>
    {
        let (max_attempts, (), queue_name, scheduled_at) = self.fields;
        let _phantom = self._phantom;
        InsertJobManyBuilder {
            fields: (max_attempts, job_data, queue_name, scheduled_at),
            _phantom,
        }
    }
}
impl<'a, MaxAttempts, JobData, ScheduledAt>
    InsertJobManyBuilder<'a, (MaxAttempts, JobData, (), ScheduledAt)>
{
    pub fn queue_name(
        self,
        queue_name: &'a str,
    ) -> InsertJobManyBuilder<'a, (MaxAttempts, JobData, &'a str, ScheduledAt)> {
        let (max_attempts, job_data, (), scheduled_at) = self.fields;
        let _phantom = self._phantom;
        InsertJobManyBuilder {
            fields: (max_attempts, job_data, queue_name, scheduled_at),
            _phantom,
        }
    }
}
impl<'a, MaxAttempts, JobData, QueueName>
    InsertJobManyBuilder<'a, (MaxAttempts, JobData, QueueName, ())>
{
    pub fn scheduled_at(
        self,
        scheduled_at: crate::PgDateTime,
    ) -> InsertJobManyBuilder<'a, (MaxAttempts, JobData, QueueName, crate::PgDateTime)> {
        let (max_attempts, job_data, queue_name, ()) = self.fields;
        let _phantom = self._phantom;
        InsertJobManyBuilder {
            fields: (max_attempts, job_data, queue_name, scheduled_at),
            _phantom,
        }
    }
}
impl<'a> InsertJobManyBuilder<'a, (i32, &'a serde_json::Value, &'a str, crate::PgDateTime)> {
    pub const fn build(self) -> InsertJobMany<'a> {
        let (max_attempts, job_data, queue_name, scheduled_at) = self.fields;
        InsertJobMany {
            max_attempts,
            job_data,
            queue_name,
            scheduled_at,
        }
    }
}
#[derive(sqlx::FromRow)]
pub struct AddJobNotifyRow {
    #[sqlx(rename = "pg_notify")]
    pub pg_notify: (),
}
pub struct AddJobNotify<'a> {
    channel_name: &'a str,
    queue_name: &'a str,
}
impl<'a> AddJobNotify<'a> {
    pub const QUERY: &'static str = r"SELECT pg_notify(
  $1::TEXT,
  json_build_object('q', $2::TEXT)::TEXT
)";
    pub fn query_as(
        &'a self,
    ) -> sqlx::query::QueryAs<
        'a,
        sqlx::Postgres,
        AddJobNotifyRow,
        <sqlx::Postgres as sqlx::Database>::Arguments<'a>,
    > {
        sqlx::query_as::<_, AddJobNotifyRow>(Self::QUERY)
            .bind(self.channel_name)
            .bind(self.queue_name)
    }
    pub fn execute<'b, A>(
        &'a self,
        conn: A,
    ) -> impl Future<Output = Result<<sqlx::Postgres as sqlx::Database>::QueryResult, sqlx::Error>>
    + Send
    + 'a
    where
        A: sqlx::Acquire<'b, Database = sqlx::Postgres> + Send + 'a,
    {
        async move {
            let mut conn = conn.acquire().await?;
            sqlx::query(Self::QUERY)
                .bind(self.channel_name)
                .bind(self.queue_name)
                .execute(&mut *conn)
                .await
        }
    }
}
impl<'a> AddJobNotify<'a> {
    pub const fn builder() -> AddJobNotifyBuilder<'a, ((), ())> {
        AddJobNotifyBuilder {
            fields: ((), ()),
            _phantom: std::marker::PhantomData,
        }
    }
}
pub struct AddJobNotifyBuilder<'a, Fields = ((), ())> {
    fields: Fields,
    _phantom: std::marker::PhantomData<&'a ()>,
}
impl<'a, QueueName> AddJobNotifyBuilder<'a, ((), QueueName)> {
    pub fn channel_name(
        self,
        channel_name: &'a str,
    ) -> AddJobNotifyBuilder<'a, (&'a str, QueueName)> {
        let ((), queue_name) = self.fields;
        let _phantom = self._phantom;
        AddJobNotifyBuilder {
            fields: (channel_name, queue_name),
            _phantom,
        }
    }
}
impl<'a, ChannelName> AddJobNotifyBuilder<'a, (ChannelName, ())> {
    pub fn queue_name(
        self,
        queue_name: &'a str,
    ) -> AddJobNotifyBuilder<'a, (ChannelName, &'a str)> {
        let (channel_name, ()) = self.fields;
        let _phantom = self._phantom;
        AddJobNotifyBuilder {
            fields: (channel_name, queue_name),
            _phantom,
        }
    }
}
impl<'a> AddJobNotifyBuilder<'a, (&'a str, &'a str)> {
    pub const fn build(self) -> AddJobNotify<'a> {
        let (channel_name, queue_name) = self.fields;
        AddJobNotify {
            channel_name,
            queue_name,
        }
    }
}
#[derive(sqlx::FromRow)]
pub struct CancelJobByIdRow {}
pub struct CancelJobById {
    id: sqlx::types::Uuid,
}
impl CancelJobById {
    pub const QUERY: &'static str = r"UPDATE
  tasuki_job j
SET 
  status = 'canceled'::tasuki_job_status
WHERE
  id = $1";
    pub fn query_as<'a>(
        &'a self,
    ) -> sqlx::query::QueryAs<
        'a,
        sqlx::Postgres,
        CancelJobByIdRow,
        <sqlx::Postgres as sqlx::Database>::Arguments<'a>,
    > {
        sqlx::query_as::<_, CancelJobByIdRow>(Self::QUERY).bind(self.id)
    }
    pub fn execute<'a, 'b, A>(
        &'a self,
        conn: A,
    ) -> impl Future<Output = Result<<sqlx::Postgres as sqlx::Database>::QueryResult, sqlx::Error>>
    + Send
    + 'a
    where
        A: sqlx::Acquire<'b, Database = sqlx::Postgres> + Send + 'a,
    {
        async move {
            let mut conn = conn.acquire().await?;
            sqlx::query(Self::QUERY)
                .bind(self.id)
                .execute(&mut *conn)
                .await
        }
    }
}
impl CancelJobById {
    pub const fn builder() -> CancelJobByIdBuilder<'static, ((),)> {
        CancelJobByIdBuilder {
            fields: ((),),
            _phantom: std::marker::PhantomData,
        }
    }
}
pub struct CancelJobByIdBuilder<'a, Fields = ((),)> {
    fields: Fields,
    _phantom: std::marker::PhantomData<&'a ()>,
}
impl<'a> CancelJobByIdBuilder<'a, ((),)> {
    pub fn id(self, id: sqlx::types::Uuid) -> CancelJobByIdBuilder<'a, (sqlx::types::Uuid,)> {
        let ((),) = self.fields;
        let _phantom = self._phantom;
        CancelJobByIdBuilder {
            fields: (id,),
            _phantom,
        }
    }
}
impl<'a> CancelJobByIdBuilder<'a, (sqlx::types::Uuid,)> {
    pub const fn build(self) -> CancelJobById {
        let (id,) = self.fields;
        CancelJobById { id }
    }
}
#[derive(sqlx::FromRow)]
pub struct RetryFailedByQueueRow {}
pub struct RetryFailedByQueue<'a> {
    queue_name: &'a str,
}
impl<'a> RetryFailedByQueue<'a> {
    pub const QUERY: &'static str = r"UPDATE tasuki_job j
SET
  status = 'pending'::tasuki_job_status,
  attempts = 0,
  scheduled_at = clock_timestamp(),
  lease_expires_at = NULL
WHERE
  j.status = 'failed'::tasuki_job_status
  AND j.attempts < j.max_attempts
  AND j.queue_name = $1::TEXT";
    pub fn query_as(
        &'a self,
    ) -> sqlx::query::QueryAs<
        'a,
        sqlx::Postgres,
        RetryFailedByQueueRow,
        <sqlx::Postgres as sqlx::Database>::Arguments<'a>,
    > {
        sqlx::query_as::<_, RetryFailedByQueueRow>(Self::QUERY).bind(self.queue_name)
    }
    pub fn execute<'b, A>(
        &'a self,
        conn: A,
    ) -> impl Future<Output = Result<<sqlx::Postgres as sqlx::Database>::QueryResult, sqlx::Error>>
    + Send
    + 'a
    where
        A: sqlx::Acquire<'b, Database = sqlx::Postgres> + Send + 'a,
    {
        async move {
            let mut conn = conn.acquire().await?;
            sqlx::query(Self::QUERY)
                .bind(self.queue_name)
                .execute(&mut *conn)
                .await
        }
    }
}
impl<'a> RetryFailedByQueue<'a> {
    pub const fn builder() -> RetryFailedByQueueBuilder<'a, ((),)> {
        RetryFailedByQueueBuilder {
            fields: ((),),
            _phantom: std::marker::PhantomData,
        }
    }
}
pub struct RetryFailedByQueueBuilder<'a, Fields = ((),)> {
    fields: Fields,
    _phantom: std::marker::PhantomData<&'a ()>,
}
impl<'a> RetryFailedByQueueBuilder<'a, ((),)> {
    pub fn queue_name(self, queue_name: &'a str) -> RetryFailedByQueueBuilder<'a, (&'a str,)> {
        let ((),) = self.fields;
        let _phantom = self._phantom;
        RetryFailedByQueueBuilder {
            fields: (queue_name,),
            _phantom,
        }
    }
}
impl<'a> RetryFailedByQueueBuilder<'a, (&'a str,)> {
    pub const fn build(self) -> RetryFailedByQueue<'a> {
        let (queue_name,) = self.fields;
        RetryFailedByQueue { queue_name }
    }
}
#[derive(sqlx::FromRow)]
pub struct AggregateQueueStatRow {
    #[sqlx(rename = "pending")]
    pub pending: i64,
    #[sqlx(rename = "running")]
    pub running: i64,
    #[sqlx(rename = "completed")]
    pub completed: i64,
    #[sqlx(rename = "failed")]
    pub failed: i64,
    #[sqlx(rename = "canceled")]
    pub canceled: i64,
}
pub struct AggregateQueueStat<'a> {
    queue_name: &'a str,
}
impl<'a> AggregateQueueStat<'a> {
    pub const QUERY: &'static str = r"SELECT 
  SUM(
    CASE WHEN status = 'pending'
      THEN 1
      ELSE 0
    END
  ) AS pending,
  SUM(
    CASE WHEN status = 'running'
      THEN 1
      ELSE 0
    END
  ) AS running,
  SUM(
    CASE WHEN status = 'completed'
      THEN 1
      ELSE 0
    END
  ) AS completed,
  SUM(
    CASE WHEN status = 'failed'
      THEN 1
      ELSE 0
    END
  ) AS failed,
  SUM(
    CASE WHEN status = 'canceled'
      THEN 1
      ELSE 0
    END
  ) AS canceled
FROM 
  tasuki_job
WHERE 
  queue_name = $1";
    pub fn query_as(
        &'a self,
    ) -> sqlx::query::QueryAs<
        'a,
        sqlx::Postgres,
        AggregateQueueStatRow,
        <sqlx::Postgres as sqlx::Database>::Arguments<'a>,
    > {
        sqlx::query_as::<_, AggregateQueueStatRow>(Self::QUERY).bind(self.queue_name)
    }
    pub fn query_one<'b, A>(
        &'a self,
        conn: A,
    ) -> impl Future<Output = Result<AggregateQueueStatRow, sqlx::Error>> + Send + 'a
    where
        A: sqlx::Acquire<'b, Database = sqlx::Postgres> + Send + 'a,
    {
        async move {
            let mut conn = conn.acquire().await?;
            let val = self.query_as().fetch_one(&mut *conn).await?;
            Ok(val)
        }
    }
    pub fn query_opt<'b, A>(
        &'a self,
        conn: A,
    ) -> impl Future<Output = Result<Option<AggregateQueueStatRow>, sqlx::Error>> + Send + 'a
    where
        A: sqlx::Acquire<'b, Database = sqlx::Postgres> + Send + 'a,
    {
        async move {
            let mut conn = conn.acquire().await?;
            let val = self.query_as().fetch_optional(&mut *conn).await?;
            Ok(val)
        }
    }
}
impl<'a> AggregateQueueStat<'a> {
    pub const fn builder() -> AggregateQueueStatBuilder<'a, ((),)> {
        AggregateQueueStatBuilder {
            fields: ((),),
            _phantom: std::marker::PhantomData,
        }
    }
}
pub struct AggregateQueueStatBuilder<'a, Fields = ((),)> {
    fields: Fields,
    _phantom: std::marker::PhantomData<&'a ()>,
}
impl<'a> AggregateQueueStatBuilder<'a, ((),)> {
    pub fn queue_name(self, queue_name: &'a str) -> AggregateQueueStatBuilder<'a, (&'a str,)> {
        let ((),) = self.fields;
        let _phantom = self._phantom;
        AggregateQueueStatBuilder {
            fields: (queue_name,),
            _phantom,
        }
    }
}
impl<'a> AggregateQueueStatBuilder<'a, (&'a str,)> {
    pub const fn build(self) -> AggregateQueueStat<'a> {
        let (queue_name,) = self.fields;
        AggregateQueueStat { queue_name }
    }
}
#[derive(sqlx::FromRow)]
pub struct CleanJobsRow {
    #[sqlx(rename = "id")]
    pub id: sqlx::types::Uuid,
}
pub struct CleanJobs<'a> {
    job_status: TasukiJobStatus,
    queue_name: &'a str,
}
impl<'a> CleanJobs<'a> {
    pub const QUERY: &'static str = r"DELETE FROM
  tasuki_job
WHERE 
  status = $1
  AND queue_name = $2
RETURNING id";
    pub fn query_as(
        &'a self,
    ) -> sqlx::query::QueryAs<
        'a,
        sqlx::Postgres,
        CleanJobsRow,
        <sqlx::Postgres as sqlx::Database>::Arguments<'a>,
    > {
        sqlx::query_as::<_, CleanJobsRow>(Self::QUERY)
            .bind(self.job_status)
            .bind(self.queue_name)
    }
    pub fn query_many<'b, A>(
        &'a self,
        conn: A,
    ) -> impl Future<Output = Result<Vec<CleanJobsRow>, sqlx::Error>> + Send + 'a
    where
        A: sqlx::Acquire<'b, Database = sqlx::Postgres> + Send + 'a,
    {
        async move {
            let mut conn = conn.acquire().await?;
            let vals = self.query_as().fetch_all(&mut *conn).await?;
            Ok(vals)
        }
    }
}
impl<'a> CleanJobs<'a> {
    pub const fn builder() -> CleanJobsBuilder<'a, ((), ())> {
        CleanJobsBuilder {
            fields: ((), ()),
            _phantom: std::marker::PhantomData,
        }
    }
}
pub struct CleanJobsBuilder<'a, Fields = ((), ())> {
    fields: Fields,
    _phantom: std::marker::PhantomData<&'a ()>,
}
impl<'a, QueueName> CleanJobsBuilder<'a, ((), QueueName)> {
    pub fn job_status(
        self,
        job_status: TasukiJobStatus,
    ) -> CleanJobsBuilder<'a, (TasukiJobStatus, QueueName)> {
        let ((), queue_name) = self.fields;
        let _phantom = self._phantom;
        CleanJobsBuilder {
            fields: (job_status, queue_name),
            _phantom,
        }
    }
}
impl<'a, JobStatus> CleanJobsBuilder<'a, (JobStatus, ())> {
    pub fn queue_name(self, queue_name: &'a str) -> CleanJobsBuilder<'a, (JobStatus, &'a str)> {
        let (job_status, ()) = self.fields;
        let _phantom = self._phantom;
        CleanJobsBuilder {
            fields: (job_status, queue_name),
            _phantom,
        }
    }
}
impl<'a> CleanJobsBuilder<'a, (TasukiJobStatus, &'a str)> {
    pub const fn build(self) -> CleanJobs<'a> {
        let (job_status, queue_name) = self.fields;
        CleanJobs {
            job_status,
            queue_name,
        }
    }
}
#[derive(sqlx::FromRow)]
pub struct ListJobsRow {
    #[sqlx(rename = "id")]
    pub id: sqlx::types::Uuid,
    #[sqlx(rename = "status")]
    pub status: TasukiJobStatus,
}
pub struct ListJobs<'a> {
    cursor_job_id: Option<sqlx::types::Uuid>,
    queue_name: Option<&'a str>,
    page_size: i32,
}
impl<'a> ListJobs<'a> {
    pub const QUERY: &'static str = r"SELECT
  j.id,
  j.status
FROM
  tasuki_job j
WHERE
  j.created_at < CASE 
    WHEN $1::UUID IS NOT NULL
      THEN (
        SELECT 
          created_at
        FROM 
          tasuki_job jj
        WHERE
          jj.id = $1::UUID
          AND jj.queue_name = $2
        )
    ELSE (
        SELECT
          MAX(created_at)
        FROM
          tasuki_job jj
        WHERE
          jj.queue_name = $2
        LIMIT 1
        )
  END
  AND j.queue_name = $2
ORDER BY j.created_at DESC, j.id DESC
LIMIT $3";
    pub fn query_as(
        &'a self,
    ) -> sqlx::query::QueryAs<
        'a,
        sqlx::Postgres,
        ListJobsRow,
        <sqlx::Postgres as sqlx::Database>::Arguments<'a>,
    > {
        sqlx::query_as::<_, ListJobsRow>(Self::QUERY)
            .bind(self.cursor_job_id)
            .bind(self.queue_name)
            .bind(self.page_size)
    }
    pub fn query_many<'b, A>(
        &'a self,
        conn: A,
    ) -> impl Future<Output = Result<Vec<ListJobsRow>, sqlx::Error>> + Send + 'a
    where
        A: sqlx::Acquire<'b, Database = sqlx::Postgres> + Send + 'a,
    {
        async move {
            let mut conn = conn.acquire().await?;
            let vals = self.query_as().fetch_all(&mut *conn).await?;
            Ok(vals)
        }
    }
}
impl<'a> ListJobs<'a> {
    pub const fn builder() -> ListJobsBuilder<'a, ((), (), ())> {
        ListJobsBuilder {
            fields: ((), (), ()),
            _phantom: std::marker::PhantomData,
        }
    }
}
pub struct ListJobsBuilder<'a, Fields = ((), (), ())> {
    fields: Fields,
    _phantom: std::marker::PhantomData<&'a ()>,
}
impl<'a, QueueName, PageSize> ListJobsBuilder<'a, ((), QueueName, PageSize)> {
    pub fn cursor_job_id(
        self,
        cursor_job_id: Option<sqlx::types::Uuid>,
    ) -> ListJobsBuilder<'a, (Option<sqlx::types::Uuid>, QueueName, PageSize)> {
        let ((), queue_name, page_size) = self.fields;
        let _phantom = self._phantom;
        ListJobsBuilder {
            fields: (cursor_job_id, queue_name, page_size),
            _phantom,
        }
    }
}
impl<'a, CursorJobId, PageSize> ListJobsBuilder<'a, (CursorJobId, (), PageSize)> {
    pub fn queue_name(
        self,
        queue_name: Option<&'a str>,
    ) -> ListJobsBuilder<'a, (CursorJobId, Option<&'a str>, PageSize)> {
        let (cursor_job_id, (), page_size) = self.fields;
        let _phantom = self._phantom;
        ListJobsBuilder {
            fields: (cursor_job_id, queue_name, page_size),
            _phantom,
        }
    }
}
impl<'a, CursorJobId, QueueName> ListJobsBuilder<'a, (CursorJobId, QueueName, ())> {
    pub fn page_size(self, page_size: i32) -> ListJobsBuilder<'a, (CursorJobId, QueueName, i32)> {
        let (cursor_job_id, queue_name, ()) = self.fields;
        let _phantom = self._phantom;
        ListJobsBuilder {
            fields: (cursor_job_id, queue_name, page_size),
            _phantom,
        }
    }
}
impl<'a> ListJobsBuilder<'a, (Option<sqlx::types::Uuid>, Option<&'a str>, i32)> {
    pub const fn build(self) -> ListJobs<'a> {
        let (cursor_job_id, queue_name, page_size) = self.fields;
        ListJobs {
            cursor_job_id,
            queue_name,
            page_size,
        }
    }
}
