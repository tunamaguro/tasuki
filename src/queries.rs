//! Code generated by sqlc-gen-rust. SHOULD NOT EDIT.
//! sqlc version: v1.29.0
//! sqlc-gen-rust version: v0.1.6

pub struct CopyDataSink<C: std::ops::DerefMut<Target = sqlx::PgConnection>> {
    encode_buf: sqlx::postgres::PgArgumentBuffer,
    data_buf: Vec<u8>,
    copy_in: sqlx::postgres::PgCopyIn<C>,
}
impl<C: std::ops::DerefMut<Target = sqlx::PgConnection>> CopyDataSink<C> {
    const BUFFER_SIZE: usize = 4096;
    fn new(copy_in: sqlx::postgres::PgCopyIn<C>) -> Self {
        let mut data_buf = Vec::with_capacity(Self::BUFFER_SIZE);
        const COPY_SIGNATURE: &[u8] = &[
            b'P', b'G', b'C', b'O', b'P', b'Y', b'\n', 0xFF, b'\r', b'\n', 0x00,
        ];
        assert_eq!(COPY_SIGNATURE.len(), 11);
        data_buf.extend_from_slice(COPY_SIGNATURE);
        data_buf.extend(0_i32.to_be_bytes());
        data_buf.extend(0_i32.to_be_bytes());
        CopyDataSink {
            encode_buf: Default::default(),
            data_buf,
            copy_in,
        }
    }
    async fn send(&mut self) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        let _copy_in = self.copy_in.send(self.data_buf.as_slice()).await?;
        self.data_buf.clear();
        Ok(())
    }
    /// Complete copy process and return number of rows affected.
    pub async fn finish(mut self) -> Result<u64, Box<dyn std::error::Error + Send + Sync>> {
        const COPY_TRAILER: &[u8] = &(-1_i16).to_be_bytes();
        self.data_buf.extend(COPY_TRAILER);
        self.send().await?;
        self.copy_in.finish().await.map_err(|e| e.into())
    }
    fn insert_row(&mut self) {
        let num_col = self.copy_in.num_columns() as i16;
        self.data_buf.extend(num_col.to_be_bytes());
    }
    async fn add<'q, T>(
        &mut self,
        value: &T,
    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>>
    where
        T: sqlx::Encode<'q, sqlx::Postgres> + sqlx::Type<sqlx::Postgres>,
    {
        let is_null = value.encode_by_ref(&mut self.encode_buf)?;
        match is_null {
            sqlx::encode::IsNull::Yes => {
                self.data_buf.extend((-1_i32).to_be_bytes());
            }
            sqlx::encode::IsNull::No => {
                self.data_buf
                    .extend((self.encode_buf.len() as i32).to_be_bytes());
                self.data_buf.extend_from_slice(self.encode_buf.as_slice());
            }
        }
        self.encode_buf.clear();
        if self.data_buf.len() > Self::BUFFER_SIZE {
            self.send().await?;
        }
        Ok(())
    }
}
#[derive(Debug, Clone, Copy, sqlx::Type)]
#[sqlx(type_name = "tasuki_job_status")]
pub enum TasukiJobStatus {
    #[sqlx(rename = "pending")]
    Pending,
    #[sqlx(rename = "running")]
    Running,
    #[sqlx(rename = "completed")]
    Completed,
    #[sqlx(rename = "failed")]
    Failed,
    #[sqlx(rename = "canceled")]
    Canceled,
}
#[derive(sqlx::FromRow)]
pub struct GetAvailableJobsRow {
    pub id: sqlx::types::Uuid,
    pub job_data: serde_json::Value,
}
pub struct GetAvailableJobs<'a> {
    lease_interval: &'a sqlx::postgres::types::PgInterval,
    queue_name: &'a str,
    batch_size: i32,
}
impl<'a> GetAvailableJobs<'a> {
    pub const QUERY: &'static str = r"UPDATE 
  tasuki_job j
SET
  status = 'running',
  attempts = j.attempts + 1,
  lease_expires_at = clock_timestamp() + $1::INTERVAL
WHERE 
  id in (
    SELECT 
      id 
    FROM
      tasuki_job
    WHERE 
      (
        (status = 'pending')
        OR
        (status = 'running' AND lease_expires_at IS NOT NULL AND lease_expires_at <= NOW())
      )
      AND 
      (scheduled_at <= NOW() AND attempts <= max_attempts AND queue_name = $2::TEXT)
    ORDER BY scheduled_at ASC
    FOR UPDATE SKIP LOCKED
    LIMIT $3
  )
RETURNING j.id, j.job_data";
    pub fn query_as(
        &'a self,
    ) -> sqlx::query::QueryAs<
        'a,
        sqlx::Postgres,
        GetAvailableJobsRow,
        <sqlx::Postgres as sqlx::Database>::Arguments<'a>,
    > {
        sqlx::query_as::<_, GetAvailableJobsRow>(Self::QUERY)
            .bind(self.lease_interval)
            .bind(self.queue_name)
            .bind(self.batch_size)
    }
    pub async fn query_many<'b, A>(
        &'a self,
        conn: A,
    ) -> Result<Vec<GetAvailableJobsRow>, sqlx::Error>
    where
        A: sqlx::Acquire<'b, Database = sqlx::Postgres> + Send + 'a,
    {
        let mut conn = conn.acquire().await?;
        let vals = self.query_as().fetch_all(&mut *conn).await?;
        Ok(vals)
    }
}
impl<'a> GetAvailableJobs<'a> {
    pub const fn builder() -> GetAvailableJobsBuilder<'a, ((), (), ())> {
        GetAvailableJobsBuilder {
            fields: ((), (), ()),
            _phantom: std::marker::PhantomData,
        }
    }
}
pub struct GetAvailableJobsBuilder<'a, Fields = ((), (), ())> {
    fields: Fields,
    _phantom: std::marker::PhantomData<&'a ()>,
}
impl<'a, QueueName, BatchSize> GetAvailableJobsBuilder<'a, ((), QueueName, BatchSize)> {
    pub fn lease_interval(
        self,
        lease_interval: &'a sqlx::postgres::types::PgInterval,
    ) -> GetAvailableJobsBuilder<'a, (&'a sqlx::postgres::types::PgInterval, QueueName, BatchSize)>
    {
        let ((), queue_name, batch_size) = self.fields;
        let _phantom = self._phantom;
        GetAvailableJobsBuilder {
            fields: (lease_interval, queue_name, batch_size),
            _phantom,
        }
    }
}
impl<'a, LeaseInterval, BatchSize> GetAvailableJobsBuilder<'a, (LeaseInterval, (), BatchSize)> {
    pub fn queue_name(
        self,
        queue_name: &'a str,
    ) -> GetAvailableJobsBuilder<'a, (LeaseInterval, &'a str, BatchSize)> {
        let (lease_interval, (), batch_size) = self.fields;
        let _phantom = self._phantom;
        GetAvailableJobsBuilder {
            fields: (lease_interval, queue_name, batch_size),
            _phantom,
        }
    }
}
impl<'a, LeaseInterval, QueueName> GetAvailableJobsBuilder<'a, (LeaseInterval, QueueName, ())> {
    pub fn batch_size(
        self,
        batch_size: i32,
    ) -> GetAvailableJobsBuilder<'a, (LeaseInterval, QueueName, i32)> {
        let (lease_interval, queue_name, ()) = self.fields;
        let _phantom = self._phantom;
        GetAvailableJobsBuilder {
            fields: (lease_interval, queue_name, batch_size),
            _phantom,
        }
    }
}
impl<'a> GetAvailableJobsBuilder<'a, (&'a sqlx::postgres::types::PgInterval, &'a str, i32)> {
    pub const fn build(self) -> GetAvailableJobs<'a> {
        let (lease_interval, queue_name, batch_size) = self.fields;
        GetAvailableJobs {
            lease_interval,
            queue_name,
            batch_size,
        }
    }
}
#[derive(sqlx::FromRow)]
pub struct HeartBeatJobRow {}
pub struct HeartBeatJob<'a> {
    id: sqlx::types::Uuid,
    lease_interval: &'a sqlx::postgres::types::PgInterval,
}
impl<'a> HeartBeatJob<'a> {
    pub const QUERY: &'static str = r"UPDATE 
  tasuki_job j
SET
  lease_expires_at = clock_timestamp() + $2::INTERVAL
WHERE
  id = $1";
    pub fn query_as(
        &'a self,
    ) -> sqlx::query::QueryAs<
        'a,
        sqlx::Postgres,
        HeartBeatJobRow,
        <sqlx::Postgres as sqlx::Database>::Arguments<'a>,
    > {
        sqlx::query_as::<_, HeartBeatJobRow>(Self::QUERY)
            .bind(self.id)
            .bind(self.lease_interval)
    }
    pub async fn execute<'b, A>(
        &'a self,
        conn: A,
    ) -> Result<<sqlx::Postgres as sqlx::Database>::QueryResult, sqlx::Error>
    where
        A: sqlx::Acquire<'b, Database = sqlx::Postgres> + Send + 'a,
    {
        let mut conn = conn.acquire().await?;
        sqlx::query(Self::QUERY)
            .bind(self.id)
            .bind(self.lease_interval)
            .execute(&mut *conn)
            .await
    }
}
impl<'a> HeartBeatJob<'a> {
    pub const fn builder() -> HeartBeatJobBuilder<'a, ((), ())> {
        HeartBeatJobBuilder {
            fields: ((), ()),
            _phantom: std::marker::PhantomData,
        }
    }
}
pub struct HeartBeatJobBuilder<'a, Fields = ((), ())> {
    fields: Fields,
    _phantom: std::marker::PhantomData<&'a ()>,
}
impl<'a, LeaseInterval> HeartBeatJobBuilder<'a, ((), LeaseInterval)> {
    pub fn id(
        self,
        id: sqlx::types::Uuid,
    ) -> HeartBeatJobBuilder<'a, (sqlx::types::Uuid, LeaseInterval)> {
        let ((), lease_interval) = self.fields;
        let _phantom = self._phantom;
        HeartBeatJobBuilder {
            fields: (id, lease_interval),
            _phantom,
        }
    }
}
impl<'a, Id> HeartBeatJobBuilder<'a, (Id, ())> {
    pub fn lease_interval(
        self,
        lease_interval: &'a sqlx::postgres::types::PgInterval,
    ) -> HeartBeatJobBuilder<'a, (Id, &'a sqlx::postgres::types::PgInterval)> {
        let (id, ()) = self.fields;
        let _phantom = self._phantom;
        HeartBeatJobBuilder {
            fields: (id, lease_interval),
            _phantom,
        }
    }
}
impl<'a> HeartBeatJobBuilder<'a, (sqlx::types::Uuid, &'a sqlx::postgres::types::PgInterval)> {
    pub const fn build(self) -> HeartBeatJob<'a> {
        let (id, lease_interval) = self.fields;
        HeartBeatJob { id, lease_interval }
    }
}
#[derive(sqlx::FromRow)]
pub struct CompleteJobRow {}
pub struct CompleteJob {
    id: sqlx::types::Uuid,
}
impl CompleteJob {
    pub const QUERY: &'static str = r"UPDATE 
  tasuki_job j
SET 
  status = 'completed'
WHERE
  id = $1";
    pub fn query_as<'a>(
        &'a self,
    ) -> sqlx::query::QueryAs<
        'a,
        sqlx::Postgres,
        CompleteJobRow,
        <sqlx::Postgres as sqlx::Database>::Arguments<'a>,
    > {
        sqlx::query_as::<_, CompleteJobRow>(Self::QUERY).bind(self.id)
    }
    pub async fn execute<'a, 'b, A>(
        &'a self,
        conn: A,
    ) -> Result<<sqlx::Postgres as sqlx::Database>::QueryResult, sqlx::Error>
    where
        A: sqlx::Acquire<'b, Database = sqlx::Postgres> + Send + 'a,
    {
        let mut conn = conn.acquire().await?;
        sqlx::query(Self::QUERY)
            .bind(self.id)
            .execute(&mut *conn)
            .await
    }
}
impl CompleteJob {
    pub const fn builder() -> CompleteJobBuilder<'static, ((),)> {
        CompleteJobBuilder {
            fields: ((),),
            _phantom: std::marker::PhantomData,
        }
    }
}
pub struct CompleteJobBuilder<'a, Fields = ((),)> {
    fields: Fields,
    _phantom: std::marker::PhantomData<&'a ()>,
}
impl<'a> CompleteJobBuilder<'a, ((),)> {
    pub fn id(self, id: sqlx::types::Uuid) -> CompleteJobBuilder<'a, (sqlx::types::Uuid,)> {
        let ((),) = self.fields;
        let _phantom = self._phantom;
        CompleteJobBuilder {
            fields: (id,),
            _phantom,
        }
    }
}
impl<'a> CompleteJobBuilder<'a, (sqlx::types::Uuid,)> {
    pub const fn build(self) -> CompleteJob {
        let (id,) = self.fields;
        CompleteJob { id }
    }
}
#[derive(sqlx::FromRow)]
pub struct CancelJobRow {}
pub struct CancelJob {
    id: sqlx::types::Uuid,
}
impl CancelJob {
    pub const QUERY: &'static str = r"UPDATE
  tasuki_job j
SET
  status = 'canceled'
WHERE
  id = $1";
    pub fn query_as<'a>(
        &'a self,
    ) -> sqlx::query::QueryAs<
        'a,
        sqlx::Postgres,
        CancelJobRow,
        <sqlx::Postgres as sqlx::Database>::Arguments<'a>,
    > {
        sqlx::query_as::<_, CancelJobRow>(Self::QUERY).bind(self.id)
    }
    pub async fn execute<'a, 'b, A>(
        &'a self,
        conn: A,
    ) -> Result<<sqlx::Postgres as sqlx::Database>::QueryResult, sqlx::Error>
    where
        A: sqlx::Acquire<'b, Database = sqlx::Postgres> + Send + 'a,
    {
        let mut conn = conn.acquire().await?;
        sqlx::query(Self::QUERY)
            .bind(self.id)
            .execute(&mut *conn)
            .await
    }
}
impl CancelJob {
    pub const fn builder() -> CancelJobBuilder<'static, ((),)> {
        CancelJobBuilder {
            fields: ((),),
            _phantom: std::marker::PhantomData,
        }
    }
}
pub struct CancelJobBuilder<'a, Fields = ((),)> {
    fields: Fields,
    _phantom: std::marker::PhantomData<&'a ()>,
}
impl<'a> CancelJobBuilder<'a, ((),)> {
    pub fn id(self, id: sqlx::types::Uuid) -> CancelJobBuilder<'a, (sqlx::types::Uuid,)> {
        let ((),) = self.fields;
        let _phantom = self._phantom;
        CancelJobBuilder {
            fields: (id,),
            _phantom,
        }
    }
}
impl<'a> CancelJobBuilder<'a, (sqlx::types::Uuid,)> {
    pub const fn build(self) -> CancelJob {
        let (id,) = self.fields;
        CancelJob { id }
    }
}
#[derive(sqlx::FromRow)]
pub struct RetryJobRow {}
pub struct RetryJob<'a> {
    id: sqlx::types::Uuid,
    interval: &'a sqlx::postgres::types::PgInterval,
}
impl<'a> RetryJob<'a> {
    pub const QUERY: &'static str = r"UPDATE tasuki_job j
SET 
  status = CASE 
            WHEN j.attempts <= j.max_attempts THEN 'pending'
            ELSE 'failed'
           END,
  scheduled_at = CASE
                  WHEN j.attempts <= j.max_attempts THEN clock_timestamp() + $2::INTERVAL
                  ELSE scheduled_at
                 END 
WHERE 
  id = $1";
    pub fn query_as(
        &'a self,
    ) -> sqlx::query::QueryAs<
        'a,
        sqlx::Postgres,
        RetryJobRow,
        <sqlx::Postgres as sqlx::Database>::Arguments<'a>,
    > {
        sqlx::query_as::<_, RetryJobRow>(Self::QUERY)
            .bind(self.id)
            .bind(self.interval)
    }
    pub async fn execute<'b, A>(
        &'a self,
        conn: A,
    ) -> Result<<sqlx::Postgres as sqlx::Database>::QueryResult, sqlx::Error>
    where
        A: sqlx::Acquire<'b, Database = sqlx::Postgres> + Send + 'a,
    {
        let mut conn = conn.acquire().await?;
        sqlx::query(Self::QUERY)
            .bind(self.id)
            .bind(self.interval)
            .execute(&mut *conn)
            .await
    }
}
impl<'a> RetryJob<'a> {
    pub const fn builder() -> RetryJobBuilder<'a, ((), ())> {
        RetryJobBuilder {
            fields: ((), ()),
            _phantom: std::marker::PhantomData,
        }
    }
}
pub struct RetryJobBuilder<'a, Fields = ((), ())> {
    fields: Fields,
    _phantom: std::marker::PhantomData<&'a ()>,
}
impl<'a, Interval> RetryJobBuilder<'a, ((), Interval)> {
    pub fn id(self, id: sqlx::types::Uuid) -> RetryJobBuilder<'a, (sqlx::types::Uuid, Interval)> {
        let ((), interval) = self.fields;
        let _phantom = self._phantom;
        RetryJobBuilder {
            fields: (id, interval),
            _phantom,
        }
    }
}
impl<'a, Id> RetryJobBuilder<'a, (Id, ())> {
    pub fn interval(
        self,
        interval: &'a sqlx::postgres::types::PgInterval,
    ) -> RetryJobBuilder<'a, (Id, &'a sqlx::postgres::types::PgInterval)> {
        let (id, ()) = self.fields;
        let _phantom = self._phantom;
        RetryJobBuilder {
            fields: (id, interval),
            _phantom,
        }
    }
}
impl<'a> RetryJobBuilder<'a, (sqlx::types::Uuid, &'a sqlx::postgres::types::PgInterval)> {
    pub const fn build(self) -> RetryJob<'a> {
        let (id, interval) = self.fields;
        RetryJob { id, interval }
    }
}
#[derive(sqlx::FromRow)]
pub struct InsertJobOneRow {}
pub struct InsertJobOne<'a> {
    max_attempts: i32,
    job_data: &'a serde_json::Value,
    queue_name: &'a str,
}
impl<'a> InsertJobOne<'a> {
    pub const QUERY: &'static str = r"INSERT INTO
  tasuki_job
  (max_attempts, job_data, queue_name)
VALUES
  ($1, $2, $3)";
    pub fn query_as(
        &'a self,
    ) -> sqlx::query::QueryAs<
        'a,
        sqlx::Postgres,
        InsertJobOneRow,
        <sqlx::Postgres as sqlx::Database>::Arguments<'a>,
    > {
        sqlx::query_as::<_, InsertJobOneRow>(Self::QUERY)
            .bind(self.max_attempts)
            .bind(self.job_data)
            .bind(self.queue_name)
    }
    pub async fn execute<'b, A>(
        &'a self,
        conn: A,
    ) -> Result<<sqlx::Postgres as sqlx::Database>::QueryResult, sqlx::Error>
    where
        A: sqlx::Acquire<'b, Database = sqlx::Postgres> + Send + 'a,
    {
        let mut conn = conn.acquire().await?;
        sqlx::query(Self::QUERY)
            .bind(self.max_attempts)
            .bind(self.job_data)
            .bind(self.queue_name)
            .execute(&mut *conn)
            .await
    }
}
impl<'a> InsertJobOne<'a> {
    pub const fn builder() -> InsertJobOneBuilder<'a, ((), (), ())> {
        InsertJobOneBuilder {
            fields: ((), (), ()),
            _phantom: std::marker::PhantomData,
        }
    }
}
pub struct InsertJobOneBuilder<'a, Fields = ((), (), ())> {
    fields: Fields,
    _phantom: std::marker::PhantomData<&'a ()>,
}
impl<'a, JobData, QueueName> InsertJobOneBuilder<'a, ((), JobData, QueueName)> {
    pub fn max_attempts(
        self,
        max_attempts: i32,
    ) -> InsertJobOneBuilder<'a, (i32, JobData, QueueName)> {
        let ((), job_data, queue_name) = self.fields;
        let _phantom = self._phantom;
        InsertJobOneBuilder {
            fields: (max_attempts, job_data, queue_name),
            _phantom,
        }
    }
}
impl<'a, MaxAttempts, QueueName> InsertJobOneBuilder<'a, (MaxAttempts, (), QueueName)> {
    pub fn job_data(
        self,
        job_data: &'a serde_json::Value,
    ) -> InsertJobOneBuilder<'a, (MaxAttempts, &'a serde_json::Value, QueueName)> {
        let (max_attempts, (), queue_name) = self.fields;
        let _phantom = self._phantom;
        InsertJobOneBuilder {
            fields: (max_attempts, job_data, queue_name),
            _phantom,
        }
    }
}
impl<'a, MaxAttempts, JobData> InsertJobOneBuilder<'a, (MaxAttempts, JobData, ())> {
    pub fn queue_name(
        self,
        queue_name: &'a str,
    ) -> InsertJobOneBuilder<'a, (MaxAttempts, JobData, &'a str)> {
        let (max_attempts, job_data, ()) = self.fields;
        let _phantom = self._phantom;
        InsertJobOneBuilder {
            fields: (max_attempts, job_data, queue_name),
            _phantom,
        }
    }
}
impl<'a> InsertJobOneBuilder<'a, (i32, &'a serde_json::Value, &'a str)> {
    pub const fn build(self) -> InsertJobOne<'a> {
        let (max_attempts, job_data, queue_name) = self.fields;
        InsertJobOne {
            max_attempts,
            job_data,
            queue_name,
        }
    }
}
