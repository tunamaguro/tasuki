//! Code generated by sqlc-gen-rust. SHOULD NOT EDIT.
//! sqlc version: v1.29.0
//! sqlc-gen-rust version: v0.1.6

pub struct CopyDataSink<C: std::ops::DerefMut<Target = sqlx::PgConnection>> {
    encode_buf: sqlx::postgres::PgArgumentBuffer,
    data_buf: Vec<u8>,
    copy_in: sqlx::postgres::PgCopyIn<C>,
}
impl<C: std::ops::DerefMut<Target = sqlx::PgConnection>> CopyDataSink<C> {
    const BUFFER_SIZE: usize = 4096;
    fn new(copy_in: sqlx::postgres::PgCopyIn<C>) -> Self {
        let mut data_buf = Vec::with_capacity(Self::BUFFER_SIZE);
        const COPY_SIGNATURE: &[u8] = &[
            b'P', b'G', b'C', b'O', b'P', b'Y', b'\n', 0xFF, b'\r', b'\n', 0x00,
        ];
        assert_eq!(COPY_SIGNATURE.len(), 11);
        data_buf.extend_from_slice(COPY_SIGNATURE);
        data_buf.extend(0_i32.to_be_bytes());
        data_buf.extend(0_i32.to_be_bytes());
        CopyDataSink {
            encode_buf: Default::default(),
            data_buf,
            copy_in,
        }
    }
    async fn send(&mut self) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        let _copy_in = self.copy_in.send(self.data_buf.as_slice()).await?;
        self.data_buf.clear();
        Ok(())
    }
    /// Complete copy process and return number of rows affected.
    pub async fn finish(
        mut self,
    ) -> Result<u64, Box<dyn std::error::Error + Send + Sync>> {
        const COPY_TRAILER: &[u8] = &(-1_i16).to_be_bytes();
        self.data_buf.extend(COPY_TRAILER);
        self.send().await?;
        self.copy_in.finish().await.map_err(|e| e.into())
    }
    fn insert_row(&mut self) {
        let num_col = self.copy_in.num_columns() as i16;
        self.data_buf.extend(num_col.to_be_bytes());
    }
    async fn add<'q, T>(
        &mut self,
        value: &T,
    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>>
    where
        T: sqlx::Encode<'q, sqlx::Postgres> + sqlx::Type<sqlx::Postgres>,
    {
        let is_null = value.encode_by_ref(&mut self.encode_buf)?;
        match is_null {
            sqlx::encode::IsNull::Yes => {
                self.data_buf.extend((-1_i32).to_be_bytes());
            }
            sqlx::encode::IsNull::No => {
                self.data_buf.extend((self.encode_buf.len() as i32).to_be_bytes());
                self.data_buf.extend_from_slice(self.encode_buf.as_slice());
            }
        }
        self.encode_buf.clear();
        if self.data_buf.len() > Self::BUFFER_SIZE {
            self.send().await?;
        }
        Ok(())
    }
}
#[derive(Debug, Clone, Copy, sqlx::Type)]
#[sqlx(type_name = "tasuki_job_status")]
pub enum TasukiJobStatus {
    #[sqlx(rename = "pending")]
    Pending,
    #[sqlx(rename = "running")]
    Running,
    #[sqlx(rename = "completed")]
    Completed,
    #[sqlx(rename = "failed")]
    Failed,
}
#[derive(sqlx::FromRow)]
pub struct GetAvailableJobsRow {
    pub id: sqlx::types::Uuid,
    pub job_data: serde_json::Value,
}
pub struct GetAvailableJobs<'a> {
    lease_interval: &'a sqlx::postgres::types::PgInterval,
    batch_size: i32,
}
impl<'a> GetAvailableJobs<'a> {
    pub const QUERY: &'static str = r"UPDATE 
  tasuki_job j
SET
  status = 'running',
  attempts = j.attempts + 1,
  lease_expires_at = clock_timestamp() + make_interval(secs := $1::INTERVAL)
WHERE 
  id in (
    SELECT 
      id 
    FROM
      tasuki_job
    WHERE 
      (status = 'pending' AND scheduled_at <= NOW())
      OR
      (status = 'running' AND lease_expires_at IS NOT NULL AND lease_expires_at <= NOW())
    ORDER BY scheduled_at ASC
    FOR UPDATE SKIP LOCKED
    LIMIT $2
  )
RETURNING j.id, j.job_data";
    pub fn query_as(
        &'a self,
    ) -> sqlx::query::QueryAs<
        'a,
        sqlx::Postgres,
        GetAvailableJobsRow,
        <sqlx::Postgres as sqlx::Database>::Arguments<'a>,
    > {
        sqlx::query_as::<_, GetAvailableJobsRow>(Self::QUERY)
            .bind(self.lease_interval)
            .bind(self.batch_size)
    }
    pub fn query_many<'b, A>(
        &'a self,
        conn: A,
    ) -> impl Future<Output = Result<Vec<GetAvailableJobsRow>, sqlx::Error>> + Send + 'a
    where
        A: sqlx::Acquire<'b, Database = sqlx::Postgres> + Send + 'a,
    {
        async move {
            let mut conn = conn.acquire().await?;
            let vals = self.query_as().fetch_all(&mut *conn).await?;
            Ok(vals)
        }
    }
}
impl<'a> GetAvailableJobs<'a> {
    pub const fn builder() -> GetAvailableJobsBuilder<'a, ((), ())> {
        GetAvailableJobsBuilder {
            fields: ((), ()),
            _phantom: std::marker::PhantomData,
        }
    }
}
pub struct GetAvailableJobsBuilder<'a, Fields = ((), ())> {
    fields: Fields,
    _phantom: std::marker::PhantomData<&'a ()>,
}
impl<'a, BatchSize> GetAvailableJobsBuilder<'a, ((), BatchSize)> {
    pub fn lease_interval(
        self,
        lease_interval: &'a sqlx::postgres::types::PgInterval,
    ) -> GetAvailableJobsBuilder<
        'a,
        (&'a sqlx::postgres::types::PgInterval, BatchSize),
    > {
        let ((), batch_size) = self.fields;
        let _phantom = self._phantom;
        GetAvailableJobsBuilder {
            fields: (lease_interval, batch_size),
            _phantom,
        }
    }
}
impl<'a, LeaseInterval> GetAvailableJobsBuilder<'a, (LeaseInterval, ())> {
    pub fn batch_size(
        self,
        batch_size: i32,
    ) -> GetAvailableJobsBuilder<'a, (LeaseInterval, i32)> {
        let (lease_interval, ()) = self.fields;
        let _phantom = self._phantom;
        GetAvailableJobsBuilder {
            fields: (lease_interval, batch_size),
            _phantom,
        }
    }
}
impl<'a> GetAvailableJobsBuilder<'a, (&'a sqlx::postgres::types::PgInterval, i32)> {
    pub const fn build(self) -> GetAvailableJobs<'a> {
        let (lease_interval, batch_size) = self.fields;
        GetAvailableJobs {
            lease_interval,
            batch_size,
        }
    }
}
#[derive(sqlx::FromRow)]
pub struct InsertJobOneRow {}
pub struct InsertJobOne<'a> {
    max_attempts: i32,
    job_data: &'a serde_json::Value,
}
impl<'a> InsertJobOne<'a> {
    pub const QUERY: &'static str = r"INSERT INTO
  tasuki_job
  (max_attempts, job_data)
VALUES
  ($1,$2)";
    pub fn query_as(
        &'a self,
    ) -> sqlx::query::QueryAs<
        'a,
        sqlx::Postgres,
        InsertJobOneRow,
        <sqlx::Postgres as sqlx::Database>::Arguments<'a>,
    > {
        sqlx::query_as::<_, InsertJobOneRow>(Self::QUERY)
            .bind(self.max_attempts)
            .bind(self.job_data)
    }
    pub fn execute<'b, A>(
        &'a self,
        conn: A,
    ) -> impl Future<
        Output = Result<<sqlx::Postgres as sqlx::Database>::QueryResult, sqlx::Error>,
    > + Send + 'a
    where
        A: sqlx::Acquire<'b, Database = sqlx::Postgres> + Send + 'a,
    {
        async move {
            let mut conn = conn.acquire().await?;
            sqlx::query(Self::QUERY)
                .bind(self.max_attempts)
                .bind(self.job_data)
                .execute(&mut *conn)
                .await
        }
    }
}
impl<'a> InsertJobOne<'a> {
    pub const fn builder() -> InsertJobOneBuilder<'a, ((), ())> {
        InsertJobOneBuilder {
            fields: ((), ()),
            _phantom: std::marker::PhantomData,
        }
    }
}
pub struct InsertJobOneBuilder<'a, Fields = ((), ())> {
    fields: Fields,
    _phantom: std::marker::PhantomData<&'a ()>,
}
impl<'a, JobData> InsertJobOneBuilder<'a, ((), JobData)> {
    pub fn max_attempts(
        self,
        max_attempts: i32,
    ) -> InsertJobOneBuilder<'a, (i32, JobData)> {
        let ((), job_data) = self.fields;
        let _phantom = self._phantom;
        InsertJobOneBuilder {
            fields: (max_attempts, job_data),
            _phantom,
        }
    }
}
impl<'a, MaxAttempts> InsertJobOneBuilder<'a, (MaxAttempts, ())> {
    pub fn job_data(
        self,
        job_data: &'a serde_json::Value,
    ) -> InsertJobOneBuilder<'a, (MaxAttempts, &'a serde_json::Value)> {
        let (max_attempts, ()) = self.fields;
        let _phantom = self._phantom;
        InsertJobOneBuilder {
            fields: (max_attempts, job_data),
            _phantom,
        }
    }
}
impl<'a> InsertJobOneBuilder<'a, (i32, &'a serde_json::Value)> {
    pub const fn build(self) -> InsertJobOne<'a> {
        let (max_attempts, job_data) = self.fields;
        InsertJobOne {
            max_attempts,
            job_data,
        }
    }
}
