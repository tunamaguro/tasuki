//! Code generated by sqlc-gen-rust. SHOULD NOT EDIT.
//! sqlc version: v1.29.0
//! sqlc-gen-rust version: v0.1.6

pub struct CopyDataSink<C: std::ops::DerefMut<Target = sqlx::PgConnection>> {
    encode_buf: sqlx::postgres::PgArgumentBuffer,
    data_buf: Vec<u8>,
    copy_in: sqlx::postgres::PgCopyIn<C>,
}
impl<C: std::ops::DerefMut<Target = sqlx::PgConnection>> CopyDataSink<C> {
    const BUFFER_SIZE: usize = 4096;
    fn new(copy_in: sqlx::postgres::PgCopyIn<C>) -> Self {
        let mut data_buf = Vec::with_capacity(Self::BUFFER_SIZE);
        const COPY_SIGNATURE: &[u8] = &[
            b'P', b'G', b'C', b'O', b'P', b'Y', b'\n', 0xFF, b'\r', b'\n', 0x00,
        ];
        assert_eq!(COPY_SIGNATURE.len(), 11);
        data_buf.extend_from_slice(COPY_SIGNATURE);
        data_buf.extend(0_i32.to_be_bytes());
        data_buf.extend(0_i32.to_be_bytes());
        CopyDataSink {
            encode_buf: Default::default(),
            data_buf,
            copy_in,
        }
    }
    async fn send(&mut self) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        let _copy_in = self.copy_in.send(self.data_buf.as_slice()).await?;
        self.data_buf.clear();
        Ok(())
    }
    /// Complete copy process and return number of rows affected.
    pub async fn finish(mut self) -> Result<u64, Box<dyn std::error::Error + Send + Sync>> {
        const COPY_TRAILER: &[u8] = &(-1_i16).to_be_bytes();
        self.data_buf.extend(COPY_TRAILER);
        self.send().await?;
        self.copy_in.finish().await.map_err(|e| e.into())
    }
    fn insert_row(&mut self) {
        let num_col = self.copy_in.num_columns() as i16;
        self.data_buf.extend(num_col.to_be_bytes());
    }
    async fn add<'q, T>(
        &mut self,
        value: &T,
    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>>
    where
        T: sqlx::Encode<'q, sqlx::Postgres> + sqlx::Type<sqlx::Postgres>,
    {
        let is_null = value.encode_by_ref(&mut self.encode_buf)?;
        match is_null {
            sqlx::encode::IsNull::Yes => {
                self.data_buf.extend((-1_i32).to_be_bytes());
            }
            sqlx::encode::IsNull::No => {
                self.data_buf
                    .extend((self.encode_buf.len() as i32).to_be_bytes());
                self.data_buf.extend_from_slice(self.encode_buf.as_slice());
            }
        }
        self.encode_buf.clear();
        if self.data_buf.len() > Self::BUFFER_SIZE {
            self.send().await?;
        }
        Ok(())
    }
}
#[derive(Debug, Clone, Copy, sqlx::Type)]
#[sqlx(type_name = "tasuki_job_status")]
pub enum TasukiJobStatus {
    #[sqlx(rename = "pending")]
    Pending,
    #[sqlx(rename = "running")]
    Running,
    #[sqlx(rename = "completed")]
    Completed,
    #[sqlx(rename = "failed")]
    Failed,
    #[sqlx(rename = "canceled")]
    Canceled,
}
#[derive(sqlx::FromRow)]
pub struct GetAvailableJobsRow {
    pub id: sqlx::types::Uuid,
    pub job_data: serde_json::Value,
    pub lease_token: Option<sqlx::types::Uuid>,
}
pub struct GetAvailableJobs<'a> {
    lease_interval: &'a sqlx::postgres::types::PgInterval,
    queue_name: &'a str,
    batch_size: i32,
}
impl<'a> GetAvailableJobs<'a> {
    pub const QUERY: &'static str = r"UPDATE 
  tasuki_job j
SET
  status = 'running'::tasuki_job_status,
  attempts = j.attempts + 1,
  lease_expires_at = clock_timestamp() + $1::INTERVAL,
  lease_token = gen_random_uuid()
WHERE 
  id in (
    SELECT 
      id 
    FROM
      tasuki_job
    WHERE 
      (
        (status = 'pending')
        OR
        (status = 'running' AND lease_expires_at IS NOT NULL AND lease_expires_at <= NOW())
      )
      AND 
      (scheduled_at <= NOW() AND attempts < max_attempts AND queue_name = $2::TEXT)
    ORDER BY scheduled_at ASC
    FOR UPDATE SKIP LOCKED
    LIMIT $3
  )
RETURNING j.id, j.job_data, j.lease_token";
    pub fn query_as(
        &'a self,
    ) -> sqlx::query::QueryAs<
        'a,
        sqlx::Postgres,
        GetAvailableJobsRow,
        <sqlx::Postgres as sqlx::Database>::Arguments<'a>,
    > {
        sqlx::query_as::<_, GetAvailableJobsRow>(Self::QUERY)
            .bind(self.lease_interval)
            .bind(self.queue_name)
            .bind(self.batch_size)
    }
    pub fn query_many<'b, A>(
        &'a self,
        conn: A,
    ) -> impl Future<Output = Result<Vec<GetAvailableJobsRow>, sqlx::Error>> + Send + 'a
    where
        A: sqlx::Acquire<'b, Database = sqlx::Postgres> + Send + 'a,
    {
        async move {
            let mut conn = conn.acquire().await?;
            let vals = self.query_as().fetch_all(&mut *conn).await?;
            Ok(vals)
        }
    }
}
impl<'a> GetAvailableJobs<'a> {
    pub const fn builder() -> GetAvailableJobsBuilder<'a, ((), (), ())> {
        GetAvailableJobsBuilder {
            fields: ((), (), ()),
            _phantom: std::marker::PhantomData,
        }
    }
}
pub struct GetAvailableJobsBuilder<'a, Fields = ((), (), ())> {
    fields: Fields,
    _phantom: std::marker::PhantomData<&'a ()>,
}
impl<'a, QueueName, BatchSize> GetAvailableJobsBuilder<'a, ((), QueueName, BatchSize)> {
    pub fn lease_interval(
        self,
        lease_interval: &'a sqlx::postgres::types::PgInterval,
    ) -> GetAvailableJobsBuilder<'a, (&'a sqlx::postgres::types::PgInterval, QueueName, BatchSize)>
    {
        let ((), queue_name, batch_size) = self.fields;
        let _phantom = self._phantom;
        GetAvailableJobsBuilder {
            fields: (lease_interval, queue_name, batch_size),
            _phantom,
        }
    }
}
impl<'a, LeaseInterval, BatchSize> GetAvailableJobsBuilder<'a, (LeaseInterval, (), BatchSize)> {
    pub fn queue_name(
        self,
        queue_name: &'a str,
    ) -> GetAvailableJobsBuilder<'a, (LeaseInterval, &'a str, BatchSize)> {
        let (lease_interval, (), batch_size) = self.fields;
        let _phantom = self._phantom;
        GetAvailableJobsBuilder {
            fields: (lease_interval, queue_name, batch_size),
            _phantom,
        }
    }
}
impl<'a, LeaseInterval, QueueName> GetAvailableJobsBuilder<'a, (LeaseInterval, QueueName, ())> {
    pub fn batch_size(
        self,
        batch_size: i32,
    ) -> GetAvailableJobsBuilder<'a, (LeaseInterval, QueueName, i32)> {
        let (lease_interval, queue_name, ()) = self.fields;
        let _phantom = self._phantom;
        GetAvailableJobsBuilder {
            fields: (lease_interval, queue_name, batch_size),
            _phantom,
        }
    }
}
impl<'a> GetAvailableJobsBuilder<'a, (&'a sqlx::postgres::types::PgInterval, &'a str, i32)> {
    pub const fn build(self) -> GetAvailableJobs<'a> {
        let (lease_interval, queue_name, batch_size) = self.fields;
        GetAvailableJobs {
            lease_interval,
            queue_name,
            batch_size,
        }
    }
}
#[derive(sqlx::FromRow)]
pub struct HeartBeatJobRow {}
pub struct HeartBeatJob<'a> {
    lease_interval: &'a sqlx::postgres::types::PgInterval,
    id: sqlx::types::Uuid,
    lease_token: Option<sqlx::types::Uuid>,
}
impl<'a> HeartBeatJob<'a> {
    pub const QUERY: &'static str = r"UPDATE 
  tasuki_job j
SET
  lease_expires_at = clock_timestamp() + $1::INTERVAL
WHERE
  id = $2
  AND lease_token = $3";
    pub fn query_as(
        &'a self,
    ) -> sqlx::query::QueryAs<
        'a,
        sqlx::Postgres,
        HeartBeatJobRow,
        <sqlx::Postgres as sqlx::Database>::Arguments<'a>,
    > {
        sqlx::query_as::<_, HeartBeatJobRow>(Self::QUERY)
            .bind(self.lease_interval)
            .bind(self.id)
            .bind(self.lease_token)
    }
    pub fn execute<'b, A>(
        &'a self,
        conn: A,
    ) -> impl Future<Output = Result<<sqlx::Postgres as sqlx::Database>::QueryResult, sqlx::Error>>
    + Send
    + 'a
    where
        A: sqlx::Acquire<'b, Database = sqlx::Postgres> + Send + 'a,
    {
        async move {
            let mut conn = conn.acquire().await?;
            sqlx::query(Self::QUERY)
                .bind(self.lease_interval)
                .bind(self.id)
                .bind(self.lease_token)
                .execute(&mut *conn)
                .await
        }
    }
}
impl<'a> HeartBeatJob<'a> {
    pub const fn builder() -> HeartBeatJobBuilder<'a, ((), (), ())> {
        HeartBeatJobBuilder {
            fields: ((), (), ()),
            _phantom: std::marker::PhantomData,
        }
    }
}
pub struct HeartBeatJobBuilder<'a, Fields = ((), (), ())> {
    fields: Fields,
    _phantom: std::marker::PhantomData<&'a ()>,
}
impl<'a, Id, LeaseToken> HeartBeatJobBuilder<'a, ((), Id, LeaseToken)> {
    pub fn lease_interval(
        self,
        lease_interval: &'a sqlx::postgres::types::PgInterval,
    ) -> HeartBeatJobBuilder<'a, (&'a sqlx::postgres::types::PgInterval, Id, LeaseToken)> {
        let ((), id, lease_token) = self.fields;
        let _phantom = self._phantom;
        HeartBeatJobBuilder {
            fields: (lease_interval, id, lease_token),
            _phantom,
        }
    }
}
impl<'a, LeaseInterval, LeaseToken> HeartBeatJobBuilder<'a, (LeaseInterval, (), LeaseToken)> {
    pub fn id(
        self,
        id: sqlx::types::Uuid,
    ) -> HeartBeatJobBuilder<'a, (LeaseInterval, sqlx::types::Uuid, LeaseToken)> {
        let (lease_interval, (), lease_token) = self.fields;
        let _phantom = self._phantom;
        HeartBeatJobBuilder {
            fields: (lease_interval, id, lease_token),
            _phantom,
        }
    }
}
impl<'a, LeaseInterval, Id> HeartBeatJobBuilder<'a, (LeaseInterval, Id, ())> {
    pub fn lease_token(
        self,
        lease_token: Option<sqlx::types::Uuid>,
    ) -> HeartBeatJobBuilder<'a, (LeaseInterval, Id, Option<sqlx::types::Uuid>)> {
        let (lease_interval, id, ()) = self.fields;
        let _phantom = self._phantom;
        HeartBeatJobBuilder {
            fields: (lease_interval, id, lease_token),
            _phantom,
        }
    }
}
impl<'a>
    HeartBeatJobBuilder<
        'a,
        (
            &'a sqlx::postgres::types::PgInterval,
            sqlx::types::Uuid,
            Option<sqlx::types::Uuid>,
        ),
    >
{
    pub const fn build(self) -> HeartBeatJob<'a> {
        let (lease_interval, id, lease_token) = self.fields;
        HeartBeatJob {
            lease_interval,
            id,
            lease_token,
        }
    }
}
#[derive(sqlx::FromRow)]
pub struct CompleteJobRow {}
pub struct CompleteJob {
    id: sqlx::types::Uuid,
    lease_token: Option<sqlx::types::Uuid>,
}
impl CompleteJob {
    pub const QUERY: &'static str = r"UPDATE 
  tasuki_job j
SET 
  status = 'completed'::tasuki_job_status,
  lease_expires_at = NULL
WHERE
  id = $1
  AND lease_token = $2";
    pub fn query_as<'a>(
        &'a self,
    ) -> sqlx::query::QueryAs<
        'a,
        sqlx::Postgres,
        CompleteJobRow,
        <sqlx::Postgres as sqlx::Database>::Arguments<'a>,
    > {
        sqlx::query_as::<_, CompleteJobRow>(Self::QUERY)
            .bind(self.id)
            .bind(self.lease_token)
    }
    pub fn execute<'a, 'b, A>(
        &'a self,
        conn: A,
    ) -> impl Future<Output = Result<<sqlx::Postgres as sqlx::Database>::QueryResult, sqlx::Error>>
    + Send
    + 'a
    where
        A: sqlx::Acquire<'b, Database = sqlx::Postgres> + Send + 'a,
    {
        async move {
            let mut conn = conn.acquire().await?;
            sqlx::query(Self::QUERY)
                .bind(self.id)
                .bind(self.lease_token)
                .execute(&mut *conn)
                .await
        }
    }
}
impl CompleteJob {
    pub const fn builder() -> CompleteJobBuilder<'static, ((), ())> {
        CompleteJobBuilder {
            fields: ((), ()),
            _phantom: std::marker::PhantomData,
        }
    }
}
pub struct CompleteJobBuilder<'a, Fields = ((), ())> {
    fields: Fields,
    _phantom: std::marker::PhantomData<&'a ()>,
}
impl<'a, LeaseToken> CompleteJobBuilder<'a, ((), LeaseToken)> {
    pub fn id(
        self,
        id: sqlx::types::Uuid,
    ) -> CompleteJobBuilder<'a, (sqlx::types::Uuid, LeaseToken)> {
        let ((), lease_token) = self.fields;
        let _phantom = self._phantom;
        CompleteJobBuilder {
            fields: (id, lease_token),
            _phantom,
        }
    }
}
impl<'a, Id> CompleteJobBuilder<'a, (Id, ())> {
    pub fn lease_token(
        self,
        lease_token: Option<sqlx::types::Uuid>,
    ) -> CompleteJobBuilder<'a, (Id, Option<sqlx::types::Uuid>)> {
        let (id, ()) = self.fields;
        let _phantom = self._phantom;
        CompleteJobBuilder {
            fields: (id, lease_token),
            _phantom,
        }
    }
}
impl<'a> CompleteJobBuilder<'a, (sqlx::types::Uuid, Option<sqlx::types::Uuid>)> {
    pub const fn build(self) -> CompleteJob {
        let (id, lease_token) = self.fields;
        CompleteJob { id, lease_token }
    }
}
#[derive(sqlx::FromRow)]
pub struct CancelJobRow {}
pub struct CancelJob {
    id: sqlx::types::Uuid,
    lease_token: Option<sqlx::types::Uuid>,
}
impl CancelJob {
    pub const QUERY: &'static str = r"UPDATE
  tasuki_job j
SET
  status = 'canceled'::tasuki_job_status,
  lease_expires_at = NULL
WHERE
  id = $1
  AND lease_token = $2";
    pub fn query_as<'a>(
        &'a self,
    ) -> sqlx::query::QueryAs<
        'a,
        sqlx::Postgres,
        CancelJobRow,
        <sqlx::Postgres as sqlx::Database>::Arguments<'a>,
    > {
        sqlx::query_as::<_, CancelJobRow>(Self::QUERY)
            .bind(self.id)
            .bind(self.lease_token)
    }
    pub fn execute<'a, 'b, A>(
        &'a self,
        conn: A,
    ) -> impl Future<Output = Result<<sqlx::Postgres as sqlx::Database>::QueryResult, sqlx::Error>>
    + Send
    + 'a
    where
        A: sqlx::Acquire<'b, Database = sqlx::Postgres> + Send + 'a,
    {
        async move {
            let mut conn = conn.acquire().await?;
            sqlx::query(Self::QUERY)
                .bind(self.id)
                .bind(self.lease_token)
                .execute(&mut *conn)
                .await
        }
    }
}
impl CancelJob {
    pub const fn builder() -> CancelJobBuilder<'static, ((), ())> {
        CancelJobBuilder {
            fields: ((), ()),
            _phantom: std::marker::PhantomData,
        }
    }
}
pub struct CancelJobBuilder<'a, Fields = ((), ())> {
    fields: Fields,
    _phantom: std::marker::PhantomData<&'a ()>,
}
impl<'a, LeaseToken> CancelJobBuilder<'a, ((), LeaseToken)> {
    pub fn id(
        self,
        id: sqlx::types::Uuid,
    ) -> CancelJobBuilder<'a, (sqlx::types::Uuid, LeaseToken)> {
        let ((), lease_token) = self.fields;
        let _phantom = self._phantom;
        CancelJobBuilder {
            fields: (id, lease_token),
            _phantom,
        }
    }
}
impl<'a, Id> CancelJobBuilder<'a, (Id, ())> {
    pub fn lease_token(
        self,
        lease_token: Option<sqlx::types::Uuid>,
    ) -> CancelJobBuilder<'a, (Id, Option<sqlx::types::Uuid>)> {
        let (id, ()) = self.fields;
        let _phantom = self._phantom;
        CancelJobBuilder {
            fields: (id, lease_token),
            _phantom,
        }
    }
}
impl<'a> CancelJobBuilder<'a, (sqlx::types::Uuid, Option<sqlx::types::Uuid>)> {
    pub const fn build(self) -> CancelJob {
        let (id, lease_token) = self.fields;
        CancelJob { id, lease_token }
    }
}
#[derive(sqlx::FromRow)]
pub struct RetryJobRow {}
pub struct RetryJob<'a> {
    interval: Option<&'a sqlx::postgres::types::PgInterval>,
    id: sqlx::types::Uuid,
    lease_token: Option<sqlx::types::Uuid>,
}
impl<'a> RetryJob<'a> {
    pub const QUERY: &'static str = r"UPDATE tasuki_job j
SET 
  status = CASE 
            WHEN j.attempts < j.max_attempts THEN 'pending'::tasuki_job_status
            ELSE 'failed'::tasuki_job_status
           END,
  scheduled_at = CASE
                  WHEN j.attempts < j.max_attempts 
                    THEN clock_timestamp() + coalesce(
                      $1,
                      make_interval(secs := power(j.attempts, 4.0) * (0.9 + random() * 0.2))
                      )::INTERVAL
                  ELSE scheduled_at
                 END,
  lease_expires_at = NULL
WHERE 
  id = $2
  AND lease_token = $3";
    pub fn query_as(
        &'a self,
    ) -> sqlx::query::QueryAs<
        'a,
        sqlx::Postgres,
        RetryJobRow,
        <sqlx::Postgres as sqlx::Database>::Arguments<'a>,
    > {
        sqlx::query_as::<_, RetryJobRow>(Self::QUERY)
            .bind(self.interval)
            .bind(self.id)
            .bind(self.lease_token)
    }
    pub fn execute<'b, A>(
        &'a self,
        conn: A,
    ) -> impl Future<Output = Result<<sqlx::Postgres as sqlx::Database>::QueryResult, sqlx::Error>>
    + Send
    + 'a
    where
        A: sqlx::Acquire<'b, Database = sqlx::Postgres> + Send + 'a,
    {
        async move {
            let mut conn = conn.acquire().await?;
            sqlx::query(Self::QUERY)
                .bind(self.interval)
                .bind(self.id)
                .bind(self.lease_token)
                .execute(&mut *conn)
                .await
        }
    }
}
impl<'a> RetryJob<'a> {
    pub const fn builder() -> RetryJobBuilder<'a, ((), (), ())> {
        RetryJobBuilder {
            fields: ((), (), ()),
            _phantom: std::marker::PhantomData,
        }
    }
}
pub struct RetryJobBuilder<'a, Fields = ((), (), ())> {
    fields: Fields,
    _phantom: std::marker::PhantomData<&'a ()>,
}
impl<'a, Id, LeaseToken> RetryJobBuilder<'a, ((), Id, LeaseToken)> {
    pub fn interval(
        self,
        interval: Option<&'a sqlx::postgres::types::PgInterval>,
    ) -> RetryJobBuilder<
        'a,
        (
            Option<&'a sqlx::postgres::types::PgInterval>,
            Id,
            LeaseToken,
        ),
    > {
        let ((), id, lease_token) = self.fields;
        let _phantom = self._phantom;
        RetryJobBuilder {
            fields: (interval, id, lease_token),
            _phantom,
        }
    }
}
impl<'a, Interval, LeaseToken> RetryJobBuilder<'a, (Interval, (), LeaseToken)> {
    pub fn id(
        self,
        id: sqlx::types::Uuid,
    ) -> RetryJobBuilder<'a, (Interval, sqlx::types::Uuid, LeaseToken)> {
        let (interval, (), lease_token) = self.fields;
        let _phantom = self._phantom;
        RetryJobBuilder {
            fields: (interval, id, lease_token),
            _phantom,
        }
    }
}
impl<'a, Interval, Id> RetryJobBuilder<'a, (Interval, Id, ())> {
    pub fn lease_token(
        self,
        lease_token: Option<sqlx::types::Uuid>,
    ) -> RetryJobBuilder<'a, (Interval, Id, Option<sqlx::types::Uuid>)> {
        let (interval, id, ()) = self.fields;
        let _phantom = self._phantom;
        RetryJobBuilder {
            fields: (interval, id, lease_token),
            _phantom,
        }
    }
}
impl<'a>
    RetryJobBuilder<
        'a,
        (
            Option<&'a sqlx::postgres::types::PgInterval>,
            sqlx::types::Uuid,
            Option<sqlx::types::Uuid>,
        ),
    >
{
    pub const fn build(self) -> RetryJob<'a> {
        let (interval, id, lease_token) = self.fields;
        RetryJob {
            interval,
            id,
            lease_token,
        }
    }
}
#[derive(sqlx::FromRow)]
pub struct InsertJobOneRow {}
pub struct InsertJobOne<'a> {
    max_attempts: i32,
    job_data: &'a serde_json::Value,
    queue_name: &'a str,
}
impl<'a> InsertJobOne<'a> {
    pub const QUERY: &'static str = r"INSERT INTO
  tasuki_job
  (max_attempts, job_data, queue_name)
VALUES
  ($1, $2, $3)";
    pub fn query_as(
        &'a self,
    ) -> sqlx::query::QueryAs<
        'a,
        sqlx::Postgres,
        InsertJobOneRow,
        <sqlx::Postgres as sqlx::Database>::Arguments<'a>,
    > {
        sqlx::query_as::<_, InsertJobOneRow>(Self::QUERY)
            .bind(self.max_attempts)
            .bind(self.job_data)
            .bind(self.queue_name)
    }
    pub fn execute<'b, A>(
        &'a self,
        conn: A,
    ) -> impl Future<Output = Result<<sqlx::Postgres as sqlx::Database>::QueryResult, sqlx::Error>>
    + Send
    + 'a
    where
        A: sqlx::Acquire<'b, Database = sqlx::Postgres> + Send + 'a,
    {
        async move {
            let mut conn = conn.acquire().await?;
            sqlx::query(Self::QUERY)
                .bind(self.max_attempts)
                .bind(self.job_data)
                .bind(self.queue_name)
                .execute(&mut *conn)
                .await
        }
    }
}
impl<'a> InsertJobOne<'a> {
    pub const fn builder() -> InsertJobOneBuilder<'a, ((), (), ())> {
        InsertJobOneBuilder {
            fields: ((), (), ()),
            _phantom: std::marker::PhantomData,
        }
    }
}
pub struct InsertJobOneBuilder<'a, Fields = ((), (), ())> {
    fields: Fields,
    _phantom: std::marker::PhantomData<&'a ()>,
}
impl<'a, JobData, QueueName> InsertJobOneBuilder<'a, ((), JobData, QueueName)> {
    pub fn max_attempts(
        self,
        max_attempts: i32,
    ) -> InsertJobOneBuilder<'a, (i32, JobData, QueueName)> {
        let ((), job_data, queue_name) = self.fields;
        let _phantom = self._phantom;
        InsertJobOneBuilder {
            fields: (max_attempts, job_data, queue_name),
            _phantom,
        }
    }
}
impl<'a, MaxAttempts, QueueName> InsertJobOneBuilder<'a, (MaxAttempts, (), QueueName)> {
    pub fn job_data(
        self,
        job_data: &'a serde_json::Value,
    ) -> InsertJobOneBuilder<'a, (MaxAttempts, &'a serde_json::Value, QueueName)> {
        let (max_attempts, (), queue_name) = self.fields;
        let _phantom = self._phantom;
        InsertJobOneBuilder {
            fields: (max_attempts, job_data, queue_name),
            _phantom,
        }
    }
}
impl<'a, MaxAttempts, JobData> InsertJobOneBuilder<'a, (MaxAttempts, JobData, ())> {
    pub fn queue_name(
        self,
        queue_name: &'a str,
    ) -> InsertJobOneBuilder<'a, (MaxAttempts, JobData, &'a str)> {
        let (max_attempts, job_data, ()) = self.fields;
        let _phantom = self._phantom;
        InsertJobOneBuilder {
            fields: (max_attempts, job_data, queue_name),
            _phantom,
        }
    }
}
impl<'a> InsertJobOneBuilder<'a, (i32, &'a serde_json::Value, &'a str)> {
    pub const fn build(self) -> InsertJobOne<'a> {
        let (max_attempts, job_data, queue_name) = self.fields;
        InsertJobOne {
            max_attempts,
            job_data,
            queue_name,
        }
    }
}
#[derive(sqlx::FromRow)]
pub struct AddJobNotifyRow {
    pub pg_notify: (),
}
pub struct AddJobNotify<'a> {
    channel_name: &'a str,
    queue_name: &'a str,
}
impl<'a> AddJobNotify<'a> {
    pub const QUERY: &'static str = r"SELECT pg_notify(
  $1::TEXT,
  json_build_object('q', $2::TEXT)::TEXT
)";
    pub fn query_as(
        &'a self,
    ) -> sqlx::query::QueryAs<
        'a,
        sqlx::Postgres,
        AddJobNotifyRow,
        <sqlx::Postgres as sqlx::Database>::Arguments<'a>,
    > {
        sqlx::query_as::<_, AddJobNotifyRow>(Self::QUERY)
            .bind(self.channel_name)
            .bind(self.queue_name)
    }
    pub fn execute<'b, A>(
        &'a self,
        conn: A,
    ) -> impl Future<Output = Result<<sqlx::Postgres as sqlx::Database>::QueryResult, sqlx::Error>>
    + Send
    + 'a
    where
        A: sqlx::Acquire<'b, Database = sqlx::Postgres> + Send + 'a,
    {
        async move {
            let mut conn = conn.acquire().await?;
            sqlx::query(Self::QUERY)
                .bind(self.channel_name)
                .bind(self.queue_name)
                .execute(&mut *conn)
                .await
        }
    }
}
impl<'a> AddJobNotify<'a> {
    pub const fn builder() -> AddJobNotifyBuilder<'a, ((), ())> {
        AddJobNotifyBuilder {
            fields: ((), ()),
            _phantom: std::marker::PhantomData,
        }
    }
}
pub struct AddJobNotifyBuilder<'a, Fields = ((), ())> {
    fields: Fields,
    _phantom: std::marker::PhantomData<&'a ()>,
}
impl<'a, QueueName> AddJobNotifyBuilder<'a, ((), QueueName)> {
    pub fn channel_name(
        self,
        channel_name: &'a str,
    ) -> AddJobNotifyBuilder<'a, (&'a str, QueueName)> {
        let ((), queue_name) = self.fields;
        let _phantom = self._phantom;
        AddJobNotifyBuilder {
            fields: (channel_name, queue_name),
            _phantom,
        }
    }
}
impl<'a, ChannelName> AddJobNotifyBuilder<'a, (ChannelName, ())> {
    pub fn queue_name(
        self,
        queue_name: &'a str,
    ) -> AddJobNotifyBuilder<'a, (ChannelName, &'a str)> {
        let (channel_name, ()) = self.fields;
        let _phantom = self._phantom;
        AddJobNotifyBuilder {
            fields: (channel_name, queue_name),
            _phantom,
        }
    }
}
impl<'a> AddJobNotifyBuilder<'a, (&'a str, &'a str)> {
    pub const fn build(self) -> AddJobNotify<'a> {
        let (channel_name, queue_name) = self.fields;
        AddJobNotify {
            channel_name,
            queue_name,
        }
    }
}
